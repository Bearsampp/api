.TH "Util" 3 "Version 2025.8.29" "Bearsampp" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Util
.SH SYNOPSIS
.br
.PP
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBchangePath\fP ($filesToScan, $rootPath=null)"
.br
.ti -1c
.RI "static \fBcheckInternetState\fP ()"
.br
.ti -1c
.RI "static \fBcleanArgv\fP ($name, $type='text')"
.br
.ti -1c
.RI "static \fBcleanGetVar\fP ($name, $type='text')"
.br
.ti -1c
.RI "static \fBcleanPostVar\fP ($name, $type='text')"
.br
.ti -1c
.RI "static \fBclearFolder\fP ($path, $exclude=array())"
.br
.ti -1c
.RI "static \fBclearFolders\fP ($paths, $exclude=array())"
.br
.ti -1c
.RI "static \fBcontains\fP ($string, $search)"
.br
.ti -1c
.RI "static \fBcp1252ToUtf8\fP ($data)"
.br
.ti -1c
.RI "static \fBdecryptFile\fP ()"
.br
.ti -1c
.RI "static \fBdeleteFolder\fP ($path)"
.br
.ti -1c
.RI "static \fBdisableLaunchStartup\fP ()"
.br
.ti -1c
.RI "static \fBenableLaunchStartup\fP ()"
.br
.ti -1c
.RI "static \fBendWith\fP ($string, $search)"
.br
.ti -1c
.RI "static \fBfindRepos\fP ($initPath, $startPath, $checkFile, $maxDepth=1)"
.br
.ti -1c
.RI "static \fBformatUnixPath\fP ($path)"
.br
.ti -1c
.RI "static \fBformatWindowsPath\fP ($path)"
.br
.ti -1c
.RI "static \fBgetApiJson\fP ($url)"
.br
.ti -1c
.RI "static \fBgetAppBinsRegKey\fP ($fromRegistry=true)"
.br
.ti -1c
.RI "static \fBgetAppPathRegKey\fP ()"
.br
.ti -1c
.RI "static \fBgetChangelogUrl\fP ($utmSource=true)"
.br
.ti -1c
.RI "static \fBgetCurlHttpHeaders\fP ($url)"
.br
.ti -1c
.RI "static \fBgetFilesToScan\fP ($path=null)"
.br
.ti -1c
.RI "static \fBgetFolderList\fP ($path)"
.br
.ti -1c
.RI "static \fBgetFopenHttpHeaders\fP ($url)"
.br
.ti -1c
.RI "static \fBgetGithubRawUrl\fP ($file)"
.br
.ti -1c
.RI "static \fBgetGithubUrl\fP ($part=null)"
.br
.ti -1c
.RI "static \fBgetGithubUserUrl\fP ($part=null)"
.br
.ti -1c
.RI "static \fBgetHeaders\fP ($host, $port, $ssl=false)"
.br
.ti -1c
.RI "static \fBgetHttpHeaders\fP ($pingUrl)"
.br
.ti -1c
.RI "static \fBgetLatestVersion\fP ($url)"
.br
.ti -1c
.RI "static \fBgetMicrotime\fP ()"
.br
.ti -1c
.RI "static \fBgetNssmEnvPaths\fP ()"
.br
.ti -1c
.RI "static \fBgetPowerShellPath\fP ()"
.br
.ti -1c
.RI "static \fBgetProcessorRegKey\fP ()"
.br
.ti -1c
.RI "static \fBgetRemoteFilesize\fP ($url, $\fBhumanFileSize\fP=true)"
.br
.ti -1c
.RI "static \fBgetStartupLnkPath\fP ()"
.br
.ti -1c
.RI "static \fBgetSysPathRegKey\fP ()"
.br
.ti -1c
.RI "static \fBgetVersionList\fP ($path)"
.br
.ti -1c
.RI "static \fBgetWebsiteUrl\fP ($path='', $fragment='', $utmSource=true)"
.br
.ti -1c
.RI "static \fBgetWebsiteUrlNoUtm\fP ($path='', $fragment='')"
.br
.ti -1c
.RI "static \fBhumanFileSize\fP ($size, $unit='')"
.br
.ti -1c
.RI "static \fBimgToBase64\fP ($path)"
.br
.ti -1c
.RI "static \fBinstallService\fP ($bin, $port, $syntaxCheckCmd, $showWindow=false)"
.br
.ti -1c
.RI "static \fBis32BitsOs\fP ()"
.br
.ti -1c
.RI "static \fBisAlphanumeric\fP ($string)"
.br
.ti -1c
.RI "static \fBisLaunchStartup\fP ()"
.br
.ti -1c
.RI "static \fBisPortInUse\fP ($port)"
.br
.ti -1c
.RI "static \fBisValidDomainName\fP ($domainName)"
.br
.ti -1c
.RI "static \fBisValidIp\fP ($ip)"
.br
.ti -1c
.RI "static \fBisValidPort\fP ($port)"
.br
.ti -1c
.RI "static \fBlogDebug\fP ($data, $file=null)"
.br
.ti -1c
.RI "static \fBlogError\fP ($data, $file=null)"
.br
.ti -1c
.RI "static \fBlogInfo\fP ($data, $file=null)"
.br
.ti -1c
.RI "static \fBlogInitClass\fP ($classInstance)"
.br
.ti -1c
.RI "static \fBlogReloadClass\fP ($classInstance)"
.br
.ti -1c
.RI "static \fBlogSeparator\fP ()"
.br
.ti -1c
.RI "static \fBlogTrace\fP ($data, $file=null)"
.br
.ti -1c
.RI "static \fBlogWarning\fP ($data, $file=null)"
.br
.ti -1c
.RI "static \fBopenFileContent\fP ($caption, $content)"
.br
.ti -1c
.RI "static \fBrandom\fP ($length=32, $withNumeric=true)"
.br
.ti -1c
.RI "static \fBremoveService\fP ($service, $name)"
.br
.ti -1c
.RI "static \fBreplaceDefine\fP ($path, $var, $value)"
.br
.ti -1c
.RI "static \fBreplaceInFile\fP ($path, $replaceList)"
.br
.ti -1c
.RI "static \fBsetAppBinsRegKey\fP ($value)"
.br
.ti -1c
.RI "static \fBsetAppPathRegKey\fP ($value)"
.br
.ti -1c
.RI "static \fBsetSysPathRegKey\fP ($value)"
.br
.ti -1c
.RI "static \fBsetupCurlHeaderWithToken\fP ()"
.br
.ti -1c
.RI "static \fBstartLoading\fP ()"
.br
.ti -1c
.RI "static \fBstartService\fP ($bin, $syntaxCheckCmd, $showWindow=false)"
.br
.ti -1c
.RI "static \fBstartWith\fP ($string, $search)"
.br
.ti -1c
.RI "static \fBstopLoading\fP ()"
.br
.ti -1c
.RI "static \fButf8ToCp1252\fP ($data)"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "const \fBLOG_DEBUG\fP = 'DEBUG'"
.br
.ti -1c
.RI "const \fBLOG_ERROR\fP = 'ERROR'"
.br
.ti -1c
.RI "const \fBLOG_INFO\fP = 'INFO'"
.br
.ti -1c
.RI "const \fBLOG_TRACE\fP = 'TRACE'"
.br
.ti -1c
.RI "const \fBLOG_WARNING\fP = 'WARNING'"
.br
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static \fBfindFile\fP ($startPath, $findFile)"
.br
.ti -1c
.RI "static \fBfindFiles\fP ($startPath, $includes=array(''), $recursive=true)"
.br
.ti -1c
.RI "static \fBgetPathsToScan\fP ()"
.br
.ti -1c
.RI "static \fBlog\fP ($data, $type, $file=null)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Utility class providing a wide range of static methods for various purposes including:
.IP "\(bu" 2
Cleaning and retrieving command line, GET, and POST variables based on type specifications\&.
.IP "\(bu" 2
String manipulation methods to check if strings contain, start with, or end with specified substrings\&.
.IP "\(bu" 2
File and directory management functions for deleting, clearing, or finding files and directories\&.
.IP "\(bu" 2
Logging functionalities tailored for different levels of verbosity (ERROR, WARNING, INFO, DEBUG, TRACE)\&.
.IP "\(bu" 2
System utilities for handling registry operations, managing environment variables, and executing system commands\&.
.IP "\(bu" 2
Network utilities to validate IPs, domains, and manage HTTP requests\&.
.IP "\(bu" 2
Helper functions for encoding, decoding, and file operations\&.
.PP

.PP
This class is designed to be used as a helper or utility class where methods are accessed statically\&. This means you do not need to instantiate it to use the methods, but can simply call them using the Util::methodName() syntax\&.

.PP
Usage Example: 
.PP
.nf
$cleanedData = Util::cleanGetVar('data', 'text');
Util::logError('An error occurred');
$isAvailable = Util::isValidIp('192\&.168\&.1\&.1');

.fi
.PP

.PP
Each method is self-contained and provides specific functionality, making this class a central point for common utility operations needed across a PHP application, especially in environments like web servers or command-line interfaces\&. 
.PP
Definition at line \fB34\fP of file \fBclass\&.util\&.php\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "changePath ( $filesToScan,  $rootPath = \fRnull\fP)\fR [static]\fP"
Replaces old path references with new path references in the specified files\&.

.PP
\fBParameters\fP
.RS 4
\fI$filesToScan\fP Array of file paths to scan and modify\&. 
.br
\fI$rootPath\fP The new root path to replace the old one\&. If null, uses a default root path\&.
.RE
.PP
\fBReturns\fP
.RS 4
array Returns an array with the count of occurrences changed and the count of files changed\&. 
.RE
.PP

.PP
Definition at line \fB1205\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1206     {
1207         global $bearsamppRoot, $bearsamppCore;
1208 
1209         $result = array(
1210             'countChangedOcc'   => 0,
1211             'countChangedFiles' => 0
1212         );
1213 
1214         $rootPath           = $rootPath != null ? $rootPath : $bearsamppRoot\->getRootPath();
1215         $unixOldPath        = self::formatUnixPath($bearsamppCore\->getLastPathContent());
1216         $windowsOldPath     = self::formatWindowsPath($bearsamppCore\->getLastPathContent());
1217         $unixCurrentPath    = self::formatUnixPath($rootPath);
1218         $windowsCurrentPath = self::formatWindowsPath($rootPath);
1219 
1220         foreach ($filesToScan as $fileToScan) {
1221             $tmpCountChangedOcc = 0;
1222             $fileContentOr      = file_get_contents($fileToScan);
1223             $fileContent        = $fileContentOr;
1224 
1225             // old path
1226             preg_match('#' \&. $unixOldPath \&. '#i', $fileContent, $unixMatches);
1227             if (!empty($unixMatches)) {
1228                 $fileContent        = str_replace($unixOldPath, $unixCurrentPath, $fileContent, $countChanged);
1229                 $tmpCountChangedOcc += $countChanged;
1230             }
1231             preg_match('#' \&. str_replace('\\\\', '\\\\\\\\', $windowsOldPath) \&. '#i', $fileContent, $windowsMatches);
1232             if (!empty($windowsMatches)) {
1233                 $fileContent        = str_replace($windowsOldPath, $windowsCurrentPath, $fileContent, $countChanged);
1234                 $tmpCountChangedOcc += $countChanged;
1235             }
1236 
1237             // placeholders
1238             preg_match('#' \&. Core::PATH_LIN_PLACEHOLDER \&. '#i', $fileContent, $unixMatches);
1239             if (!empty($unixMatches)) {
1240                 $fileContent        = str_replace(Core::PATH_LIN_PLACEHOLDER, $unixCurrentPath, $fileContent, $countChanged);
1241                 $tmpCountChangedOcc += $countChanged;
1242             }
1243             preg_match('#' \&. Core::PATH_WIN_PLACEHOLDER \&. '#i', $fileContent, $windowsMatches);
1244             if (!empty($windowsMatches)) {
1245                 $fileContent        = str_replace(Core::PATH_WIN_PLACEHOLDER, $windowsCurrentPath, $fileContent, $countChanged);
1246                 $tmpCountChangedOcc += $countChanged;
1247             }
1248 
1249             if ($fileContentOr != $fileContent) {
1250                 $result['countChangedOcc']   += $tmpCountChangedOcc;
1251                 $result['countChangedFiles'] += 1;
1252                 file_put_contents($fileToScan, $fileContent);
1253             }
1254         }
1255 
1256         return $result;
1257     }
.PP
.fi

.PP
References \fB$bearsamppCore\fP, \fB$bearsamppRoot\fP, \fB$result\fP, \fBformatUnixPath()\fP, \fBformatWindowsPath()\fP, \fBCore\\PATH_LIN_PLACEHOLDER\fP, and \fBCore\\PATH_WIN_PLACEHOLDER\fP\&.
.PP
Referenced by \fBActionStartup\\changePath()\fP, and \fBActionSwitchVersion\\processWindow()\fP\&.
.SS "checkInternetState ()\fR [static]\fP"
Checks the current state of the internet connection\&.

.PP
This method attempts to reach a well-known website (e\&.g\&., www\&.google\&.com) to determine the state of the internet connection\&. It returns \fRtrue\fP if the connection is successful, otherwise it returns \fRfalse\fP\&.

.PP
\fBReturns\fP
.RS 4
bool True if the internet connection is active, false otherwise\&. 
.RE
.PP

.PP
Definition at line \fB1999\fP of file \fBclass\&.util\&.php\fP\&.
.nf
2000     {
2001         $connected = @fsockopen('www\&.google\&.com', 80);
2002         if ($connected) {
2003             fclose($connected);
2004 
2005             return true; // Internet connection is active
2006         } else {
2007             return false; // Internet connection is not active
2008         }
2009     }
.PP
.fi

.PP
Referenced by \fBQuickPick\\getQuickpickMenu()\fP, and \fBQuickPick\\installModule()\fP\&.
.SS "cleanArgv ( $name,  $type = \fR'text'\fP)\fR [static]\fP"
Cleans and returns a specific command line argument based on the type specified\&.

.PP
\fBParameters\fP
.RS 4
\fI$name\fP The index of the argument in the $_SERVER['argv'] array\&. 
.br
\fI$type\fP The type of the argument to return: 'text', 'numeric', 'boolean', or 'array'\&.
.RE
.PP
\fBReturns\fP
.RS 4
mixed Returns the cleaned argument based on the type or false if the argument is not set\&. 
.RE
.PP

.PP
Definition at line \fB53\fP of file \fBclass\&.util\&.php\fP\&.
.nf
54     {
55         if (isset($_SERVER['argv'])) {
56             if ($type == 'text') {
57                 return (isset($_SERVER['argv'][$name]) && !empty($_SERVER['argv'][$name])) ? trim($_SERVER['argv'][$name]) : '';
58             } elseif ($type == 'numeric') {
59                 return (isset($_SERVER['argv'][$name]) && is_numeric($_SERVER['argv'][$name])) ? intval($_SERVER['argv'][$name]) : '';
60             } elseif ($type == 'boolean') {
61                 return (isset($_SERVER['argv'][$name])) ? true : false;
62             } elseif ($type == 'array') {
63                 return (isset($_SERVER['argv'][$name]) && is_array($_SERVER['argv'][$name])) ? $_SERVER['argv'][$name] : array();
64             }
65         }
66 
67         return false;
68     }
.PP
.fi

.PP
Referenced by \fBAction\\process()\fP\&.
.SS "cleanGetVar ( $name,  $type = \fR'text'\fP)\fR [static]\fP"
Cleans and returns a specific $_GET variable based on the type specified\&.

.PP
\fBParameters\fP
.RS 4
\fI$name\fP The name of the $_GET variable\&. 
.br
\fI$type\fP The type of the variable to return: 'text', 'numeric', 'boolean', or 'array'\&.
.RE
.PP
\fBReturns\fP
.RS 4
mixed Returns the cleaned $_GET variable based on the type or false if the variable is not set\&. 
.RE
.PP

.PP
Definition at line \fB78\fP of file \fBclass\&.util\&.php\fP\&.
.nf
79     {
80         if (is_string($name)) {
81             if ($type == 'text') {
82                 return (isset($_GET[$name]) && !empty($_GET[$name])) ? stripslashes($_GET[$name]) : '';
83             } elseif ($type == 'numeric') {
84                 return (isset($_GET[$name]) && is_numeric($_GET[$name])) ? intval($_GET[$name]) : '';
85             } elseif ($type == 'boolean') {
86                 return (isset($_GET[$name])) ? true : false;
87             } elseif ($type == 'array') {
88                 return (isset($_GET[$name]) && is_array($_GET[$name])) ? $_GET[$name] : array();
89             }
90         }
91 
92         return false;
93     }
.PP
.fi

.PP
Referenced by \fBHomepage\\__construct()\fP\&.
.SS "cleanPostVar ( $name,  $type = \fR'text'\fP)\fR [static]\fP"
Cleans and returns a specific $_POST variable based on the type specified\&.

.PP
\fBParameters\fP
.RS 4
\fI$name\fP The name of the $_POST variable\&. 
.br
\fI$type\fP The type of the variable to return: 'text', 'number', 'float', 'boolean', 'array', or 'content'\&.
.RE
.PP
\fBReturns\fP
.RS 4
mixed Returns the cleaned $_POST variable based on the type or false if the variable is not set\&. 
.RE
.PP

.PP
Definition at line \fB103\fP of file \fBclass\&.util\&.php\fP\&.
.nf
104     {
105         if (is_string($name)) {
106             if ($type == 'text') {
107                 return (isset($_POST[$name]) && !empty($_POST[$name])) ? stripslashes(trim($_POST[$name])) : '';
108             } elseif ($type == 'number') {
109                 return (isset($_POST[$name]) && is_numeric($_POST[$name])) ? intval($_POST[$name]) : '';
110             } elseif ($type == 'float') {
111                 return (isset($_POST[$name]) && is_numeric($_POST[$name])) ? floatval($_POST[$name]) : '';
112             } elseif ($type == 'boolean') {
113                 return (isset($_POST[$name])) ? true : false;
114             } elseif ($type == 'array') {
115                 return (isset($_POST[$name]) && is_array($_POST[$name])) ? $_POST[$name] : array();
116             } elseif ($type == 'content') {
117                 return (isset($_POST[$name]) && !empty($_POST[$name])) ? trim($_POST[$name]) : '';
118             }
119         }
120 
121         return false;
122     }
.PP
.fi

.SS "clearFolder ( $path,  $exclude = \fRarray()\fP)\fR [static]\fP"
Recursively clears all files and directories within a specified directory, excluding specified items\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP The path of the directory to clear\&. 
.br
\fI$exclude\fP An array of filenames to exclude from deletion\&.
.RE
.PP
\fBReturns\fP
.RS 4
array|null Returns an array with the operation status and count of files deleted, or null if the directory cannot be opened\&. 
.RE
.PP

.PP
Definition at line \fB234\fP of file \fBclass\&.util\&.php\fP\&.
.nf
235     {
236         $result             = array();
237         $result['return']   = true;
238         $result['nb_files'] = 0;
239 
240         $handle = @opendir($path);
241         if (!$handle) {
242             return null;
243         }
244 
245         while (false !== ($file = readdir($handle))) {
246             if ($file == '\&.' || $file == '\&.\&.' || in_array($file, $exclude)) {
247                 continue;
248             }
249             if (is_dir($path \&. '/' \&. $file)) {
250                 $r = self::clearFolder($path \&. '/' \&. $file);
251                 if (!$r) {
252                     $result['return'] = false;
253 
254                     return $result;
255                 }
256             } else {
257                 $r = @unlink($path \&. '/' \&. $file);
258                 if ($r) {
259                     $result['nb_files']++;
260                 } else {
261                     $result['return'] = false;
262 
263                     return $result;
264                 }
265             }
266         }
267 
268         closedir($handle);
269 
270         return $result;
271     }
.PP
.fi

.PP
References \fB$result\fP, and \fBclearFolder()\fP\&.
.PP
Referenced by \fBActionClearFolders\\__construct()\fP, \fBActionStartup\\cleanTmpFolders()\fP, \fBclearFolder()\fP, and \fBclearFolders()\fP\&.
.SS "clearFolders ( $paths,  $exclude = \fRarray()\fP)\fR [static]\fP"
Recursively deletes files from a specified directory while excluding certain files\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP The path to the directory to clear\&. 
.br
\fI$exclude\fP An array of filenames to exclude from deletion\&.
.RE
.PP
\fBReturns\fP
.RS 4
array Returns an array with the status of the operation and the number of files deleted\&. 
.RE
.PP

.PP
Definition at line \fB216\fP of file \fBclass\&.util\&.php\fP\&.
.nf
217     {
218         $result = array();
219         foreach ($paths as $path) {
220             $result[$path] = self::clearFolder($path, $exclude);
221         }
222 
223         return $result;
224     }
.PP
.fi

.PP
References \fB$result\fP, and \fBclearFolder()\fP\&.
.SS "contains ( $string,  $search)\fR [static]\fP"
Checks if a string contains a specified substring\&.

.PP
\fBParameters\fP
.RS 4
\fI$string\fP The string to search in\&. 
.br
\fI$search\fP The substring to search for\&.
.RE
.PP
\fBReturns\fP
.RS 4
bool Returns true if the substring is found in the string, otherwise false\&. 
.RE
.PP

.PP
Definition at line \fB132\fP of file \fBclass\&.util\&.php\fP\&.
.nf
133     {
134         if (!empty($string) && !empty($search)) {
135             $result = stripos($string, $search);
136             if ($result !== false) {
137                 return true;
138             } else {
139                 return false;
140             }
141         } else {
142             return false;
143         }
144     }
.PP
.fi

.PP
References \fB$result\fP\&.
.PP
Referenced by \fBBinMailpit\\checkPort()\fP, \fBBinXlight\\checkPort()\fP, \fBBinMariadb\\getCmdLineOutput()\fP, \fBBinMysql\\getCmdLineOutput()\fP, \fBis32BitsOs()\fP, and \fBWin32Ps\\killBins()\fP\&.
.SS "cp1252ToUtf8 ( $data)\fR [static]\fP"
Converts Windows-1252 encoded data to UTF-8 encoding\&.

.PP
\fBParameters\fP
.RS 4
\fI$data\fP The Windows-1252 encoded data\&.
.RE
.PP
\fBReturns\fP
.RS 4
string Returns the data encoded in UTF-8\&. 
.RE
.PP

.PP
Definition at line \fB927\fP of file \fBclass\&.util\&.php\fP\&.
.nf
928     {
929         return iconv('WINDOWS\-1252', 'UTF\-8//IGNORE', $data);
930     }
.PP
.fi

.SS "decryptFile ()\fR [static]\fP"
Decrypts a file encrypted with a specified method and returns the content\&.

.PP
\fBReturns\fP
.RS 4
string|false Decrypted content or false on failure\&. 
.RE
.PP

.PP
Definition at line \fB1922\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1923     {
1924         global $bearsamppCore, $bearsamppConfig;
1925 
1926         $stringfile = $bearsamppCore\->getResourcesPath() \&. '/string\&.dat';
1927         $encryptedFile = $bearsamppCore\->getResourcesPath() \&. '/github\&.dat';
1928         $method        = 'AES\-256\-CBC'; // The same encryption method used
1929 
1930         // Get key string
1931         $stringPhrase = @file_get_contents($stringfile);
1932         if ($stringPhrase === false) {
1933             Util::logDebug("Failed to read the file at path: {$stringfile}");
1934 
1935             return false;
1936         }
1937 
1938         $stringKey = convert_uudecode($stringPhrase);
1939 
1940         // Read the encrypted data from the file
1941         $encryptedData = file_get_contents($encryptedFile);
1942         if ($encryptedData === false) {
1943             Util::logDebug("Failed to read the file at path: {$encryptedFile}");
1944 
1945             return false;
1946         }
1947 
1948         // Decode the base64 encoded data
1949         $data = base64_decode($encryptedData);
1950         if ($data === false) {
1951             Util::logDebug("Failed to decode the data from path: {$encryptedFile}");
1952 
1953             return false;
1954         }
1955 
1956         // Extract the IV which was prepended to the encrypted data
1957         $ivLength  = openssl_cipher_iv_length($method);
1958         $iv        = substr($data, 0, $ivLength);
1959         $encrypted = substr($data, $ivLength);
1960 
1961         // Decrypt the data
1962         $decrypted = openssl_decrypt($encrypted, $method, $stringKey, 0, $iv);
1963         if ($decrypted === false) {
1964             Util::logDebug("Decryption failed for data from path: {$encryptedFile}");
1965 
1966             return false;
1967         }
1968 
1969         return $decrypted;
1970     }
.PP
.fi

.PP
References \fB$bearsamppConfig\fP, \fB$bearsamppCore\fP, and \fBlogDebug()\fP\&.
.PP
Referenced by \fBsetupCurlHeaderWithToken()\fP\&.
.SS "deleteFolder ( $path)\fR [static]\fP"
Recursively deletes a directory and all its contents\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP The path of the directory to delete\&. 
.RE
.PP

.PP
Definition at line \fB278\fP of file \fBclass\&.util\&.php\fP\&.
.nf
279     {
280         if (is_dir($path)) {
281             if (substr($path, strlen($path) \- 1, 1) != '/') {
282                 $path \&.= '/';
283             }
284             $files = glob($path \&. '*', GLOB_MARK);
285             foreach ($files as $file) {
286                 if (is_dir($file)) {
287                     self::deleteFolder($file);
288                 } else {
289                     unlink($file);
290                 }
291             }
292             rmdir($path);
293         }
294     }
.PP
.fi

.PP
References \fBdeleteFolder()\fP\&.
.PP
Referenced by \fBdeleteFolder()\fP, and \fBActionStartup\\rotationLogs()\fP\&.
.SS "disableLaunchStartup ()\fR [static]\fP"
Disables launching the application at startup by removing the shortcut from the startup folder\&.

.PP
\fBReturns\fP
.RS 4
bool True on success, false on failure\&. 
.RE
.PP

.PP
Definition at line \fB649\fP of file \fBclass\&.util\&.php\fP\&.
.nf
650     {
651         $startupLnkPath = self::getStartupLnkPath();
652 
653         // Check if file exists before attempting to delete
654         if (file_exists($startupLnkPath)) {
655             return @unlink($startupLnkPath);
656         }
657 
658         // Return true if the file doesn't exist (already disabled)
659         return true;
660     }
.PP
.fi

.PP
References \fBgetStartupLnkPath()\fP\&.
.PP
Referenced by \fBActionLaunchStartup\\__construct()\fP, and \fBActionStartup\\checkLaunchStartup()\fP\&.
.SS "enableLaunchStartup ()\fR [static]\fP"
Enables launching the application at startup by creating a shortcut in the startup folder\&.

.PP
\fBReturns\fP
.RS 4
bool True on success, false on failure\&. 
.RE
.PP

.PP
Definition at line \fB639\fP of file \fBclass\&.util\&.php\fP\&.
.nf
640     {
641         return Vbs::createShortcut(self::getStartupLnkPath());
642     }
.PP
.fi

.PP
References \fBVbs\\createShortcut()\fP\&.
.PP
Referenced by \fBActionLaunchStartup\\__construct()\fP, and \fBActionStartup\\checkLaunchStartup()\fP\&.
.SS "endWith ( $string,  $search)\fR [static]\fP"
Checks if a string ends with a specified substring\&.

.PP
This method trims the right side whitespace of the input string before checking if it ends with the specified search substring\&.

.PP
\fBParameters\fP
.RS 4
\fI$string\fP The string to check\&. 
.br
\fI$search\fP The substring to look for at the end of the string\&.
.RE
.PP
\fBReturns\fP
.RS 4
bool Returns true if the string ends with the search substring, otherwise false\&. 
.RE
.PP

.PP
Definition at line \fB177\fP of file \fBclass\&.util\&.php\fP\&.
.nf
178     {
179         $length = strlen($search);
180         $start  = $length * \-1;
181 
182         return (substr($string, $start) === $search);
183     }
.PP
.fi

.PP
Referenced by \fBBatch\\exec()\fP, \fBBinApache\\getAlias()\fP, \fBBinPhp\\getExtensionsFromFolder()\fP, \fBLangProc\\getList()\fP, \fBTplAppLogs\\getMenuLogs()\fP, \fBBinApache\\getModulesFromFolder()\fP, \fBBatch\\getProcessUsingPort()\fP, and \fBBinApache\\getVhosts()\fP\&.
.SS "findFile ( $startPath,  $findFile)\fR [static]\fP, \fR [private]\fP"
Recursively searches for a file starting from a specified directory\&.

.PP
\fBParameters\fP
.RS 4
\fI$startPath\fP The directory path to start the search\&. 
.br
\fI$findFile\fP The filename to search for\&.
.RE
.PP
\fBReturns\fP
.RS 4
string|false Returns the path to the file if found, or false if not found\&. 
.RE
.PP

.PP
Definition at line \fB304\fP of file \fBclass\&.util\&.php\fP\&.
.nf
305     {
306         $result = false;
307 
308         $handle = @opendir($startPath);
309         if (!$handle) {
310             return false;
311         }
312 
313         while (false !== ($file = readdir($handle))) {
314             if ($file == '\&.' || $file == '\&.\&.') {
315                 continue;
316             }
317             if (is_dir($startPath \&. '/' \&. $file)) {
318                 $result = self::findFile($startPath \&. '/' \&. $file, $findFile);
319                 if ($result !== false) {
320                     break;
321                 }
322             } elseif ($file == $findFile) {
323                 $result = self::formatUnixPath($startPath \&. '/' \&. $file);
324                 break;
325             }
326         }
327 
328         closedir($handle);
329 
330         return $result;
331     }
.PP
.fi

.PP
References \fB$result\fP, \fBfindFile()\fP, and \fBformatUnixPath()\fP\&.
.PP
Referenced by \fBfindFile()\fP, and \fBgetPowerShellPath()\fP\&.
.SS "findFiles ( $startPath,  $includes = \fRarray('')\fP,  $recursive = \fRtrue\fP)\fR [static]\fP, \fR [private]\fP"
Recursively finds files in a directory that match a set of inclusion patterns\&.

.PP
\fBParameters\fP
.RS 4
\fI$startPath\fP The directory path to start the search from\&. 
.br
\fI$includes\fP An array of file patterns to include in the search\&. Patterns starting with '!' are excluded\&. 
.br
\fI$recursive\fP Determines whether the search should be recursive\&.
.RE
.PP
\fBReturns\fP
.RS 4
array An array of files that match the inclusion patterns\&. 
.RE
.PP

.PP
Definition at line \fB1158\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1159     {
1160         $result = array();
1161 
1162         $handle = @opendir($startPath);
1163         if (!$handle) {
1164             return $result;
1165         }
1166 
1167         while (false !== ($file = readdir($handle))) {
1168             if ($file == '\&.' || $file == '\&.\&.') {
1169                 continue;
1170             }
1171             if (is_dir($startPath \&. '/' \&. $file) && $recursive) {
1172                 $tmpResults = self::findFiles($startPath \&. '/' \&. $file, $includes);
1173                 foreach ($tmpResults as $tmpResult) {
1174                     $result[] = $tmpResult;
1175                 }
1176             } elseif (is_file($startPath \&. '/' \&. $file)) {
1177                 foreach ($includes as $include) {
1178                     if (self::startWith($include, '!')) {
1179                         $include = ltrim($include, '!');
1180                         if (self::startWith($file, '\&.') && !self::endWith($file, $include)) {
1181                             $result[] = self::formatUnixPath($startPath \&. '/' \&. $file);
1182                         } elseif ($file != $include) {
1183                             $result[] = self::formatUnixPath($startPath \&. '/' \&. $file);
1184                         }
1185                     } elseif (self::endWith($file, $include) || $file == $include || empty($include)) {
1186                         $result[] = self::formatUnixPath($startPath \&. '/' \&. $file);
1187                     }
1188                 }
1189             }
1190         }
1191 
1192         closedir($handle);
1193 
1194         return $result;
1195     }
.PP
.fi

.PP
References \fB$result\fP, \fBfindFiles()\fP, and \fBformatUnixPath()\fP\&.
.PP
Referenced by \fBfindFiles()\fP, and \fBgetFilesToScan()\fP\&.
.SS "findRepos ( $initPath,  $startPath,  $checkFile,  $maxDepth = \fR1\fP)\fR [static]\fP"
Recursively searches for repositories starting from a given path up to a specified depth\&.

.PP
\fBParameters\fP
.RS 4
\fI$initPath\fP The initial path from where the search begins\&. 
.br
\fI$startPath\fP The current path from where to search\&. 
.br
\fI$checkFile\fP The file name to check for in the directory to consider it a repository\&. 
.br
\fI$maxDepth\fP The maximum depth of directories to search into\&.
.RE
.PP
\fBReturns\fP
.RS 4
array Returns an array of paths that contain the specified file\&. 
.RE
.PP

.PP
Definition at line \fB840\fP of file \fBclass\&.util\&.php\fP\&.
.nf
841     {
842         $depth  = substr_count(str_replace($initPath, '', $startPath), '/');
843         $result = array();
844 
845         $handle = @opendir($startPath);
846         if (!$handle) {
847             return $result;
848         }
849 
850         while (false !== ($file = readdir($handle))) {
851             if ($file == '\&.' || $file == '\&.\&.') {
852                 continue;
853             }
854             if (is_dir($startPath \&. '/' \&. $file) && ($initPath == $startPath || $depth <= $maxDepth)) {
855                 $tmpResults = self::findRepos($initPath, $startPath \&. '/' \&. $file, $checkFile, $maxDepth);
856                 foreach ($tmpResults as $tmpResult) {
857                     $result[] = $tmpResult;
858                 }
859             } elseif (is_file($startPath \&. '/' \&. $checkFile) && !in_array($startPath, $result)) {
860                 $result[] = self::formatUnixPath($startPath);
861             }
862         }
863 
864         closedir($handle);
865 
866         return $result;
867     }
.PP
.fi

.PP
References \fB$result\fP, \fBfindRepos()\fP, and \fBformatUnixPath()\fP\&.
.PP
Referenced by \fBToolGit\\findRepos()\fP, and \fBfindRepos()\fP\&.
.SS "formatUnixPath ( $path)\fR [static]\fP"
Converts a Windows-style path to a Unix-style path\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP The Windows-style path to convert\&.
.RE
.PP
\fBReturns\fP
.RS 4
string Returns the converted Unix-style path\&. 
.RE
.PP

.PP
Definition at line \fB888\fP of file \fBclass\&.util\&.php\fP\&.
.nf
889     {
890         return str_replace('\\\\', '/', $path);
891     }
.PP
.fi

.PP
Referenced by \fBchangePath()\fP, \fBRoot\\errorHandler()\fP, \fBWin32Ps\\findByPath()\fP, \fBfindFile()\fP, \fBfindFiles()\fP, \fBfindRepos()\fP, \fBBinApache\\getAliasContent()\fP, \fBgetNssmEnvPaths()\fP, \fBVbs\\getSpecialPath()\fP, \fBBinApache\\getVhostContent()\fP, \fBWin32Ps\\killBins()\fP, \fBActionStartup\\killOldInstances()\fP, \fBActionGenSslCertificate\\processWindow()\fP, \fBActionStartup\\processWindow()\fP, and \fBToolGit\\reload()\fP\&.
.SS "formatWindowsPath ( $path)\fR [static]\fP"
Converts a Unix-style path to a Windows-style path\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP The Unix-style path to convert\&.
.RE
.PP
\fBReturns\fP
.RS 4
string Returns the converted Windows-style path\&. 
.RE
.PP

.PP
Definition at line \fB876\fP of file \fBclass\&.util\&.php\fP\&.
.nf
877     {
878         return str_replace('/', '\\\\', $path);
879     }
.PP
.fi

.PP
Referenced by \fBActionAddVhost\\__construct()\fP, \fBActionEditAlias\\__construct()\fP, \fBActionEditVhost\\__construct()\fP, \fBActionGenSslCertificate\\__construct()\fP, \fBchangePath()\fP, \fBActionStartup\\checkPathRegKey()\fP, \fBBatch\\createSymlink()\fP, \fBModule\\createSymlink()\fP, \fBgetAppBinsRegKey()\fP, \fBToolConsoleZ\\getShell()\fP, \fBBatch\\getTmpFile()\fP, \fBBatch\\installPostgresqlService()\fP, \fBopenFileContent()\fP, \fBBatch\\refreshEnvVars()\fP, \fBBatch\\removeSymlink()\fP, \fBNssm\\setBinPath()\fP, \fBWin32Service\\setBinPath()\fP, \fBNssm\\setEnvironmentExtra()\fP, and \fBBatch\\uninstallPostgresqlService()\fP\&.
.SS "getApiJson ( $url)\fR [static]\fP"
Sends a GET request to the specified URL and returns the response\&.

.PP
\fBParameters\fP
.RS 4
\fI$url\fP The URL to send the GET request to\&.
.RE
.PP
\fBReturns\fP
.RS 4
string The trimmed response data from the URL\&. 
.RE
.PP

.PP
Definition at line \fB1559\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1560     {
1561         $header = self::setupCurlHeaderWithToken();
1562 
1563         $ch = curl_init();
1564         curl_setopt($ch, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);
1565         curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
1566         curl_setopt($ch, CURLOPT_VERBOSE, true);
1567         curl_setopt($ch, CURLOPT_URL, $url);
1568         curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
1569         curl_setopt($ch, CURLOPT_HTTPHEADER, $header);
1570         $data = curl_exec($ch);
1571         if (curl_errno($ch)) {
1572             Util::logError('CURL Error: ' \&. curl_error($ch));
1573         }
1574         curl_close($ch);
1575 
1576         return trim($data);
1577     }
.PP
.fi

.PP
References \fBlogError()\fP, and \fBsetupCurlHeaderWithToken()\fP\&.
.PP
Referenced by \fBgetLatestVersion()\fP\&.
.SS "getAppBinsRegKey ( $fromRegistry = \fRtrue\fP)\fR [static]\fP"

.PP
Definition at line \fB452\fP of file \fBclass\&.util\&.php\fP\&.
.nf
453     {
454         global $bearsamppRegistry;
455 
456         if ($fromRegistry) {
457             $value = $bearsamppRegistry\->getValue(
458                 Registry::HKEY_LOCAL_MACHINE,
459                 Registry::ENV_KEY,
460                 Registry::APP_BINS_REG_ENTRY
461             );
462             self::logDebug('App reg key from registry: ' \&. $value);
463         } else {
464             global $bearsamppBins, $bearsamppTools;
465             $value = '';
466             if ($bearsamppBins\->getApache()\->isEnable()) {
467                 $value \&.= $bearsamppBins\->getApache()\->getSymlinkPath() \&. '/bin;';
468             }
469             if ($bearsamppBins\->getPhp()\->isEnable()) {
470                 $value \&.= $bearsamppBins\->getPhp()\->getSymlinkPath() \&. ';';
471                 $value \&.= $bearsamppBins\->getPhp()\->getSymlinkPath() \&. '/pear;';
472                 $value \&.= $bearsamppBins\->getPhp()\->getSymlinkPath() \&. '/deps;';
473                 $value \&.= $bearsamppBins\->getPhp()\->getSymlinkPath() \&. '/imagick;';
474             }
475             if ($bearsamppBins\->getNodejs()\->isEnable()) {
476                 $value \&.= $bearsamppBins\->getNodejs()\->getSymlinkPath() \&. ';';
477             }
478             if ($bearsamppTools\->getComposer()\->isEnable()) {
479                 $value \&.= $bearsamppTools\->getComposer()\->getSymlinkPath() \&. ';';
480                 $value \&.= $bearsamppTools\->getComposer()\->getSymlinkPath() \&. '/vendor/bin;';
481             }
482             if ($bearsamppTools\->getGhostscript()\->isEnable()) {
483                 $value \&.= $bearsamppTools\->getGhostscript()\->getSymlinkPath() \&. '/bin;';
484             }
485             if ($bearsamppTools\->getGit()\->isEnable()) {
486                 $value \&.= $bearsamppTools\->getGit()\->getSymlinkPath() \&. '/bin;';
487             }
488             if ($bearsamppTools\->getNgrok()\->isEnable()) {
489                 $value \&.= $bearsamppTools\->getNgrok()\->getSymlinkPath() \&. ';';
490             }
491             if ($bearsamppTools\->getPerl()\->isEnable()) {
492                 $value \&.= $bearsamppTools\->getPerl()\->getSymlinkPath() \&. '/perl/site/bin;';
493                 $value \&.= $bearsamppTools\->getPerl()\->getSymlinkPath() \&. '/perl/bin;';
494                 $value \&.= $bearsamppTools\->getPerl()\->getSymlinkPath() \&. '/c/bin;';
495             }
496             if ($bearsamppTools\->getPython()\->isEnable()) {
497                 $value \&.= $bearsamppTools\->getPython()\->getSymlinkPath() \&. '/bin;';
498             }
499             if ($bearsamppTools\->getRuby()\->isEnable()) {
500                 $value \&.= $bearsamppTools\->getRuby()\->getSymlinkPath() \&. '/bin;';
501             }
502             $value = self::formatWindowsPath($value);
503             self::logDebug('Generated app bins reg key: ' \&. $value);
504         }
505 
506         return $value;
507     }
.PP
.fi

.PP
References \fB$bearsamppBins\fP, \fBRegistry\\APP_BINS_REG_ENTRY\fP, \fBRegistry\\ENV_KEY\fP, \fBformatWindowsPath()\fP, \fBRegistry\\HKEY_LOCAL_MACHINE\fP, and \fBlogDebug()\fP\&.
.PP
Referenced by \fBActionStartup\\checkBinsRegKey()\fP, \fBWin32Service\\create()\fP, and \fBActionSwitchVersion\\processWindow()\fP\&.
.SS "getAppPathRegKey ()\fR [static]\fP"
Retrieves the application path from the registry\&.

.PP
\fBReturns\fP
.RS 4
mixed The value of the application path registry key or false on error\&. 
.RE
.PP

.PP
Definition at line \fB533\fP of file \fBclass\&.util\&.php\fP\&.
.nf
534     {
535         global $bearsamppRegistry;
536 
537         return $bearsamppRegistry\->getValue(
538             Registry::HKEY_LOCAL_MACHINE,
539             Registry::ENV_KEY,
540             Registry::APP_PATH_REG_ENTRY
541         );
542     }
.PP
.fi

.PP
References \fBRegistry\\APP_PATH_REG_ENTRY\fP, \fBRegistry\\ENV_KEY\fP, and \fBRegistry\\HKEY_LOCAL_MACHINE\fP\&.
.PP
Referenced by \fBActionStartup\\checkPathRegKey()\fP\&.
.SS "getChangelogUrl ( $utmSource = \fRtrue\fP)\fR [static]\fP"
Constructs the URL to the changelog page, optionally including UTM parameters\&.

.PP
\fBParameters\fP
.RS 4
\fI$utmSource\fP Whether to include UTM source parameters\&.
.RE
.PP
\fBReturns\fP
.RS 4
string The URL to the changelog page\&. 
.RE
.PP

.PP
Definition at line \fB1339\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1340     {
1341         return self::getWebsiteUrl('doc/changelog', null, $utmSource);
1342     }
.PP
.fi

.PP
References \fBgetWebsiteUrl()\fP\&.
.SS "getCurlHttpHeaders ( $url)\fR [static]\fP"
Retrieves HTTP headers from a given URL using cURL\&.

.PP
This method initializes a cURL session, sets various options to fetch headers including disabling SSL peer verification, and executes the request\&. It logs the raw response for debugging purposes and parses the headers from the response\&.

.PP
\fBParameters\fP
.RS 4
\fI$url\fP The URL from which to fetch the headers\&.
.RE
.PP
\fBReturns\fP
.RS 4
array An array of headers if successful, otherwise an empty array\&. 
.RE
.PP

.PP
Definition at line \fB1477\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1478     {
1479         $result = array();
1480 
1481         $ch = curl_init();
1482         curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
1483         curl_setopt($ch, CURLOPT_VERBOSE, true);
1484         curl_setopt($ch, CURLOPT_HEADER, true);
1485         curl_setopt($ch, CURLOPT_URL, $url);
1486         curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
1487 
1488         $response = @curl_exec($ch);
1489         if (empty($response)) {
1490             return $result;
1491         }
1492 
1493         self::logTrace('getCurlHttpHeaders:' \&. $response);
1494         $responseHeaders = explode("\\r\\n\\r\\n", $response, 2);
1495         if (!isset($responseHeaders[0]) || empty($responseHeaders[0])) {
1496             return $result;
1497         }
1498 
1499         return explode("\\n", $responseHeaders[0]);
1500     }
.PP
.fi

.PP
References \fB$response\fP, \fB$result\fP, and \fBlogTrace()\fP\&.
.PP
Referenced by \fBgetHttpHeaders()\fP\&.
.SS "getFilesToScan ( $path = \fRnull\fP)\fR [static]\fP"
Retrieves a list of files to scan from specified paths or default paths\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP Optional\&. The path to start scanning from\&. If null, uses default paths\&.
.RE
.PP
\fBReturns\fP
.RS 4
array Returns an array of files found during the scan\&. 
.RE
.PP

.PP
Definition at line \fB963\fP of file \fBclass\&.util\&.php\fP\&.
.nf
964     {
965         $result      = array();
966         $pathsToScan = !empty($path) ? $path : self::getPathsToScan();
967         foreach ($pathsToScan as $pathToScan) {
968             $startTime = self::getMicrotime();
969             $findFiles = self::findFiles($pathToScan['path'], $pathToScan['includes'], $pathToScan['recursive']);
970             foreach ($findFiles as $findFile) {
971                 $result[] = $findFile;
972             }
973             self::logDebug($pathToScan['path'] \&. ' scanned in ' \&. round(self::getMicrotime() \- $startTime, 3) \&. 's');
974         }
975 
976         return $result;
977     }
.PP
.fi

.PP
References \fB$result\fP, \fBfindFiles()\fP, \fBgetMicrotime()\fP, \fBgetPathsToScan()\fP, and \fBlogDebug()\fP\&.
.PP
Referenced by \fBActionSwitchVersion\\processWindow()\fP, and \fBActionStartup\\scanFolders()\fP\&.
.SS "getFolderList ( $path)\fR [static]\fP"
Retrieves a list of folders from a specified directory, excluding certain directories\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP The directory path from which to list folders\&.
.RE
.PP
\fBReturns\fP
.RS 4
array|bool An array of folder names, or false if the directory cannot be opened\&. 
.RE
.PP

.PP
Definition at line \fB1837\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1838     {
1839         $result = array();
1840 
1841         $handle = @opendir($path);
1842         if (!$handle) {
1843             return false;
1844         }
1845 
1846         while (false !== ($file = readdir($handle))) {
1847             $filePath = $path \&. '/' \&. $file;
1848             if ($file != '\&.' && $file != '\&.\&.' && is_dir($filePath) && $file != 'current') {
1849                 $result[] = $file;
1850             }
1851         }
1852 
1853         closedir($handle);
1854 
1855         return $result;
1856     }
.PP
.fi

.PP
References \fB$result\fP\&.
.PP
Referenced by \fBActionSwitchVersion\\__construct()\fP, and \fBgetPathsToScan()\fP\&.
.SS "getFopenHttpHeaders ( $url)\fR [static]\fP"
Retrieves HTTP headers from a given URL using the fopen function\&.

.PP
This method creates a stream context to disable SSL peer and peer name verification, which allows self-signed certificates\&. It attempts to open the URL and read the HTTP response headers\&.

.PP
\fBParameters\fP
.RS 4
\fI$url\fP The URL from which to fetch the headers\&.
.RE
.PP
\fBReturns\fP
.RS 4
array An array of headers if successful, otherwise an empty array\&. 
.RE
.PP

.PP
Definition at line \fB1444\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1445     {
1446         $result = array();
1447 
1448         $context = stream_context_create(array(
1449             'ssl' => array(
1450                 'verify_peer'       => false,
1451                 'verify_peer_name'  => false,
1452                 'allow_self_signed' => true,
1453             )
1454         ));
1455 
1456         $fp = @fopen($url, 'r', false, $context);
1457         if ($fp) {
1458             $meta   = stream_get_meta_data($fp);
1459             $result = isset($meta['wrapper_data']) ? $meta['wrapper_data'] : $result;
1460             fclose($fp);
1461         }
1462 
1463         return $result;
1464     }
.PP
.fi

.PP
References \fB$result\fP\&.
.PP
Referenced by \fBgetHttpHeaders()\fP\&.
.SS "getGithubRawUrl ( $file)\fR [static]\fP"
Constructs a URL for raw content from a GitHub repository\&.

.PP
\fBParameters\fP
.RS 4
\fI$file\fP The file path to append to the base URL\&.
.RE
.PP
\fBReturns\fP
.RS 4
string The full URL to the raw content on GitHub\&. 
.RE
.PP

.PP
Definition at line \fB1823\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1824     {
1825         $file = !empty($file) ? '/' \&. $file : null;
1826 
1827         return 'https://raw\&.githubusercontent\&.com/' \&. APP_GITHUB_USER \&. '/' \&. APP_GITHUB_REPO \&. '/main' \&. $file;
1828     }
.PP
.fi

.PP
References \fBAPP_GITHUB_REPO\fP, and \fBAPP_GITHUB_USER\fP\&.
.SS "getGithubUrl ( $part = \fRnull\fP)\fR [static]\fP"
Constructs a GitHub repository URL with an optional path\&.

.PP
\fBParameters\fP
.RS 4
\fI$part\fP Optional path to append to the URL\&.
.RE
.PP
\fBReturns\fP
.RS 4
string The full GitHub repository URL\&. 
.RE
.PP

.PP
Definition at line \fB1809\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1810     {
1811         $part = !empty($part) ? '/' \&. $part : null;
1812 
1813         return self::getGithubUserUrl(APP_GITHUB_REPO \&. $part);
1814     }
.PP
.fi

.PP
References \fBAPP_GITHUB_REPO\fP, and \fBgetGithubUserUrl()\fP\&.
.SS "getGithubUserUrl ( $part = \fRnull\fP)\fR [static]\fP"
Constructs a GitHub user URL with an optional path\&.

.PP
\fBParameters\fP
.RS 4
\fI$part\fP Optional path to append to the URL\&.
.RE
.PP
\fBReturns\fP
.RS 4
string The full GitHub user URL\&. 
.RE
.PP

.PP
Definition at line \fB1795\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1796     {
1797         $part = !empty($part) ? '/' \&. $part : null;
1798 
1799         return 'https://github\&.com/' \&. APP_GITHUB_USER \&. $part;
1800     }
.PP
.fi

.PP
References \fBAPP_GITHUB_USER\fP\&.
.PP
Referenced by \fBActionAbout\\__construct()\fP, \fBgetGithubUrl()\fP, and \fBActionAbout\\processWindow()\fP\&.
.SS "getHeaders ( $host,  $port,  $ssl = \fRfalse\fP)\fR [static]\fP"
Retrieves the initial response line from a specified host and port using a socket connection\&.

.PP
This method optionally uses SSL and creates a stream context similar to \fRgetFopenHttpHeaders\fP\&. It attempts to connect to the host and port, reads the first line of the response, and parses it\&. Detailed debug information is logged for each header line received\&.

.PP
\fBParameters\fP
.RS 4
\fI$host\fP The host name or IP address to connect to\&. 
.br
\fI$port\fP The port number to connect to\&. 
.br
\fI$ssl\fP Whether to use SSL (defaults to false)\&.
.RE
.PP
\fBReturns\fP
.RS 4
array An array containing the first line of the response, split into parts, or an empty array if unsuccessful\&. 
.RE
.PP

.PP
Definition at line \fB1515\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1516     {
1517         $result  = array();
1518         $context = stream_context_create(array(
1519             'ssl' => array(
1520                 'verify_peer'       => false,
1521                 'verify_peer_name'  => false,
1522                 'allow_self_signed' => true,
1523             )
1524         ));
1525 
1526         $fp = @stream_socket_client(($ssl ? 'ssl://' : '') \&. $host \&. ':' \&. $port, $errno, $errstr, 5, STREAM_CLIENT_CONNECT, $context);
1527         if ($fp) {
1528             $out    = fgets($fp);
1529             $result = explode(PHP_EOL, $out);
1530             @fclose($fp);
1531         }
1532 
1533         if (!empty($result)) {
1534             $rebuildResult = array();
1535             foreach ($result as $row) {
1536                 $row = trim($row);
1537                 if (!empty($row)) {
1538                     $rebuildResult[] = $row;
1539                 }
1540             }
1541             $result = $rebuildResult;
1542 
1543             self::logDebug('getHeaders:');
1544             foreach ($result as $header) {
1545                 self::logDebug('\-> ' \&. $header);
1546             }
1547         }
1548 
1549         return $result;
1550     }
.PP
.fi

.PP
References \fB$port\fP, \fB$result\fP, and \fBlogDebug()\fP\&.
.PP
Referenced by \fBBinMailpit\\checkPort()\fP, and \fBBinXlight\\checkPort()\fP\&.
.SS "getHttpHeaders ( $pingUrl)\fR [static]\fP"
Retrieves HTTP headers from a given URL using either cURL or fopen, depending on availability\&.

.PP
\fBParameters\fP
.RS 4
\fI$pingUrl\fP The URL to ping for headers\&.
.RE
.PP
\fBReturns\fP
.RS 4
array An array of HTTP headers\&. 
.RE
.PP

.PP
Definition at line \fB1406\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1407     {
1408         if (function_exists('curl_version')) {
1409             $result = self::getCurlHttpHeaders($pingUrl);
1410         } else {
1411             $result = self::getFopenHttpHeaders($pingUrl);
1412         }
1413 
1414         if (!empty($result)) {
1415             $rebuildResult = array();
1416             foreach ($result as $row) {
1417                 $row = trim($row);
1418                 if (!empty($row)) {
1419                     $rebuildResult[] = $row;
1420                 }
1421             }
1422             $result = $rebuildResult;
1423 
1424             self::logDebug('getHttpHeaders:');
1425             foreach ($result as $header) {
1426                 self::logDebug('\-> ' \&. $header);
1427             }
1428         }
1429 
1430         return $result;
1431     }
.PP
.fi

.PP
References \fB$result\fP, \fBgetCurlHttpHeaders()\fP, \fBgetFopenHttpHeaders()\fP, and \fBlogDebug()\fP\&.
.PP
Referenced by \fBBinApache\\checkPort()\fP\&.
.SS "getLatestVersion ( $url)\fR [static]\fP"
Fetches the latest version information from a given URL\&.

.PP
\fBParameters\fP
.RS 4
\fI$url\fP The URL to fetch version information from\&.
.RE
.PP
\fBReturns\fP
.RS 4
array|null Returns an array with 'version' and 'url' if successful, null otherwise\&. 
.RE
.PP

.PP
Definition at line \fB1266\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1267     {
1268         $result = self::getApiJson($url);
1269         if (empty($result)) {
1270             self::logError('Cannot retrieve latest github info for: ' \&. $result \&. ' RESULT');
1271 
1272             return null;
1273         }
1274 
1275         $resultArray = json_decode($result, true);
1276         if (isset($resultArray['tag_name']) && isset($resultArray['assets'][0]['browser_download_url'])) {
1277             $tagName     = $resultArray['tag_name'];
1278             $downloadUrl = $resultArray['assets'][0]['browser_download_url'];
1279             $name        = $resultArray['name'];
1280             self::logDebug('Latest version tag name: ' \&. $tagName);
1281             self::logDebug('Download URL: ' \&. $downloadUrl);
1282             self::logDebug('Name: ' \&. $name);
1283 
1284             return ['version' => $tagName, 'html_url' => $downloadUrl, 'name' => $name];
1285         } else {
1286             self::logError('Tag name, download URL, or name not found in the response: ' \&. $result);
1287 
1288             return null;
1289         }
1290     }
.PP
.fi

.PP
References \fB$result\fP, \fBgetApiJson()\fP, \fBlogDebug()\fP, and \fBlogError()\fP\&.
.PP
Referenced by \fBActionCheckVersion\\__construct()\fP, and \fBActionCheckVersion\\processWindow()\fP\&.
.SS "getMicrotime ()\fR [static]\fP"
Gets the current Unix timestamp with microseconds\&.

.PP
\fBReturns\fP
.RS 4
float Returns the current Unix timestamp combined with microseconds\&. 
.RE
.PP

.PP
Definition at line \fB445\fP of file \fBclass\&.util\&.php\fP\&.
.nf
446     {
447         list($usec, $sec) = explode(' ', microtime());
448 
449         return ((float)$usec + (float)$sec);
450     }
.PP
.fi

.PP
Referenced by \fBActionStartup\\__construct()\fP, \fBgetFilesToScan()\fP, \fBActionStartup\\installServices()\fP, and \fBActionStartup\\processWindow()\fP\&.
.SS "getNssmEnvPaths ()\fR [static]\fP"
Retrieves and formats environment paths from a data file\&. Paths are verified to be directories and formatted to Unix style\&. Warnings are logged for paths that do not exist\&.

.PP
\fBReturns\fP
.RS 4
string A semicolon-separated string of formatted environment paths\&. @global object $bearsamppRoot Global object containing root path methods\&. 
.RE
.PP

.PP
Definition at line \fB1866\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1867     {
1868         global $bearsamppRoot;
1869 
1870         $result           = '';
1871         $nssmEnvPathsFile = $bearsamppRoot\->getRootPath() \&. '/nssmEnvPaths\&.dat';
1872 
1873         if (is_file($nssmEnvPathsFile)) {
1874             $paths = explode(PHP_EOL, file_get_contents($nssmEnvPathsFile));
1875             foreach ($paths as $path) {
1876                 $path = trim($path);
1877                 if (stripos($path, ':') === false) {
1878                     $path = $bearsamppRoot\->getRootPath() \&. '/' \&. $path;
1879                 }
1880                 if (is_dir($path)) {
1881                     $result \&.= self::formatUnixPath($path) \&. ';';
1882                 } else {
1883                     self::logWarning('Path not found in nssmEnvPaths\&.dat: ' \&. $path);
1884                 }
1885             }
1886         }
1887 
1888         return $result;
1889     }
.PP
.fi

.PP
References \fB$bearsamppRoot\fP, \fB$result\fP, \fBformatUnixPath()\fP, and \fBlogWarning()\fP\&.
.PP
Referenced by \fBWin32Service\\create()\fP\&.
.SS "getPathsToScan ()\fR [static]\fP, \fR [private]\fP"
Retrieves a list of directories and file types to scan within the BEARSAMPP environment\&.

.PP
This method compiles an array of paths from various components of the BEARSAMPP stack, including Apache, PHP, MySQL, MariaDB, PostgreSQL, Node\&.js, Composer, ConsoleZ, Python and Ruby\&. Each path entry includes the directory path, file types to include in the scan, and whether the scan should be recursive\&.

.PP
The method uses global variables to access the root paths of each component\&. It then dynamically fetches specific subdirectories using the \fRgetFolderList\fP method (which is assumed to be defined elsewhere in this class or in the global scope) and constructs an array of path specifications\&.

.PP
Each path specification is an associative array with the following keys:
.IP "\(bu" 2
'path': The full directory path to scan\&.
.IP "\(bu" 2
'includes': An array of file extensions or filenames to include in the scan\&.
.IP "\(bu" 2
'recursive': A boolean indicating whether the scan should include subdirectories\&.
.PP

.PP
The method is designed to be used for setting up scans of configuration files and other important files within the BEARSAMPP environment, possibly for purposes like configuration management, backup, or security auditing\&.

.PP
\fBReturns\fP
.RS 4
array An array of associative arrays, each containing 'path', 'includes', and 'recursive' keys\&. 
.RE
.PP

.PP
Definition at line \fB1003\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1004     {
1005         global $bearsamppRoot, $bearsamppCore, $bearsamppBins, $bearsamppApps, $bearsamppTools;
1006         $paths = array();
1007 
1008         // Alias
1009         $paths[] = array(
1010             'path'      => $bearsamppRoot\->getAliasPath(),
1011             'includes'  => array(''),
1012             'recursive' => false
1013         );
1014 
1015         // Vhosts
1016         $paths[] = array(
1017             'path'      => $bearsamppRoot\->getVhostsPath(),
1018             'includes'  => array(''),
1019             'recursive' => false
1020         );
1021 
1022         // OpenSSL
1023         $paths[] = array(
1024             'path'      => $bearsamppCore\->getOpenSslPath(),
1025             'includes'  => array('openssl\&.cfg'),
1026             'recursive' => false
1027         );
1028 
1029         // Homepage
1030         $paths[] = array(
1031             'path'      => $bearsamppCore\->getResourcesPath() \&. '/homepage',
1032             'includes'  => array('alias\&.conf'),
1033             'recursive' => false
1034         );
1035 
1036         // Apache
1037         $folderList = self::getFolderList($bearsamppBins\->getApache()\->getRootPath());
1038         foreach ($folderList as $folder) {
1039             $paths[] = array(
1040                 'path'      => $bearsamppBins\->getApache()\->getRootPath() \&. '/' \&. $folder,
1041                 'includes'  => array('\&.ini', '\&.conf'),
1042                 'recursive' => true
1043             );
1044         }
1045 
1046         // PHP
1047         $folderList = self::getFolderList($bearsamppBins\->getPhp()\->getRootPath());
1048         foreach ($folderList as $folder) {
1049             $paths[] = array(
1050                 'path'      => $bearsamppBins\->getPhp()\->getRootPath() \&. '/' \&. $folder,
1051                 'includes'  => array('\&.php', '\&.bat', '\&.ini', '\&.reg', '\&.inc'),
1052                 'recursive' => true
1053             );
1054         }
1055 
1056         // MySQL
1057         $folderList = self::getFolderList($bearsamppBins\->getMysql()\->getRootPath());
1058         foreach ($folderList as $folder) {
1059             $paths[] = array(
1060                 'path'      => $bearsamppBins\->getMysql()\->getRootPath() \&. '/' \&. $folder,
1061                 'includes'  => array('my\&.ini'),
1062                 'recursive' => false
1063             );
1064         }
1065 
1066         // MariaDB
1067         $folderList = self::getFolderList($bearsamppBins\->getMariadb()\->getRootPath());
1068         foreach ($folderList as $folder) {
1069             $paths[] = array(
1070                 'path'      => $bearsamppBins\->getMariadb()\->getRootPath() \&. '/' \&. $folder,
1071                 'includes'  => array('my\&.ini'),
1072                 'recursive' => false
1073             );
1074         }
1075 
1076         // PostgreSQL
1077         $folderList = self::getFolderList($bearsamppBins\->getPostgresql()\->getRootPath());
1078         foreach ($folderList as $folder) {
1079             $paths[] = array(
1080                 'path'      => $bearsamppBins\->getPostgresql()\->getRootPath() \&. '/' \&. $folder,
1081                 'includes'  => array('\&.ber', '\&.conf', '\&.bat'),
1082                 'recursive' => true
1083             );
1084         }
1085 
1086         // Node\&.js
1087         $folderList = self::getFolderList($bearsamppBins\->getNodejs()\->getRootPath());
1088         foreach ($folderList as $folder) {
1089             $paths[] = array(
1090                 'path'      => $bearsamppBins\->getNodejs()\->getRootPath() \&. '/' \&. $folder \&. '/etc',
1091                 'includes'  => array('npmrc'),
1092                 'recursive' => true
1093             );
1094             $paths[] = array(
1095                 'path'      => $bearsamppBins\->getNodejs()\->getRootPath() \&. '/' \&. $folder \&. '/node_modules/npm',
1096                 'includes'  => array('npmrc'),
1097                 'recursive' => false
1098             );
1099         }
1100 
1101         // Composer
1102         $folderList = self::getFolderList($bearsamppTools\->getComposer()\->getRootPath());
1103         foreach ($folderList as $folder) {
1104             $paths[] = array(
1105                 'path'      => $bearsamppTools\->getComposer()\->getRootPath() \&. '/' \&. $folder,
1106                 'includes'  => array('giscus\&.json'),
1107                 'recursive' => false
1108             );
1109         }
1110 
1111         // ConsoleZ
1112         $folderList = self::getFolderList($bearsamppTools\->getConsoleZ()\->getRootPath());
1113         foreach ($folderList as $folder) {
1114             $paths[] = array(
1115                 'path'      => $bearsamppTools\->getConsoleZ()\->getRootPath() \&. '/' \&. $folder,
1116                 'includes'  => array('console\&.xml', '\&.ini', '\&.btm'),
1117                 'recursive' => true
1118             );
1119         }
1120 
1121         // Python
1122         $folderList = self::getFolderList($bearsamppTools\->getPython()\->getRootPath());
1123         foreach ($folderList as $folder) {
1124             $paths[] = array(
1125                 'path'      => $bearsamppTools\->getPython()\->getRootPath() \&. '/' \&. $folder \&. '/bin',
1126                 'includes'  => array('\&.bat'),
1127                 'recursive' => false
1128             );
1129             $paths[] = array(
1130                 'path'      => $bearsamppTools\->getPython()\->getRootPath() \&. '/' \&. $folder \&. '/settings',
1131                 'includes'  => array('winpython\&.ini'),
1132                 'recursive' => false
1133             );
1134         }
1135 
1136         // Ruby
1137         $folderList = self::getFolderList($bearsamppTools\->getRuby()\->getRootPath());
1138         foreach ($folderList as $folder) {
1139             $paths[] = array(
1140                 'path'      => $bearsamppTools\->getRuby()\->getRootPath() \&. '/' \&. $folder \&. '/bin',
1141                 'includes'  => array('!\&.dll', '!\&.exe'),
1142                 'recursive' => false
1143             );
1144         }
1145 
1146         return $paths;
1147     }
.PP
.fi

.PP
References \fB$bearsamppBins\fP, \fB$bearsamppCore\fP, \fB$bearsamppRoot\fP, and \fBgetFolderList()\fP\&.
.PP
Referenced by \fBgetFilesToScan()\fP\&.
.SS "getPowerShellPath ()\fR [static]\fP"
Finds the path to the PowerShell executable in the Windows System32 directory\&.

.PP
\fBReturns\fP
.RS 4
string|false Returns the path to powershell\&.exe if found, otherwise false\&. 
.RE
.PP

.PP
Definition at line \fB821\fP of file \fBclass\&.util\&.php\fP\&.
.nf
822     {
823         if (is_dir('C:\\Windows\\System32\\WindowsPowerShell')) {
824             return self::findFile('C:\\Windows\\System32\\WindowsPowerShell', 'powershell\&.exe');
825         }
826 
827         return false;
828     }
.PP
.fi

.PP
References \fBfindFile()\fP\&.
.PP
Referenced by \fBTplConsoleZ\\getTabPowerShellSection()\fP\&.
.SS "getProcessorRegKey ()\fR [static]\fP"
Retrieves the processor identifier from the registry\&.

.PP
\fBReturns\fP
.RS 4
mixed The value of the processor identifier registry key or false on error\&. 
.RE
.PP

.PP
Definition at line \fB603\fP of file \fBclass\&.util\&.php\fP\&.
.nf
604     {
605         global $bearsamppRegistry;
606 
607         return $bearsamppRegistry\->getValue(
608             Registry::HKEY_LOCAL_MACHINE,
609             Registry::PROCESSOR_REG_SUBKEY,
610             Registry::PROCESSOR_REG_ENTRY
611         );
612     }
.PP
.fi

.PP
References \fBRegistry\\HKEY_LOCAL_MACHINE\fP, \fBRegistry\\PROCESSOR_REG_ENTRY\fP, and \fBRegistry\\PROCESSOR_REG_SUBKEY\fP\&.
.PP
Referenced by \fBis32BitsOs()\fP\&.
.SS "getRemoteFilesize ( $url,  $humanFileSize = \fRtrue\fP)\fR [static]\fP"
Retrieves the file size of a remote file\&.

.PP
\fBParameters\fP
.RS 4
\fI$url\fP The URL of the remote file\&. 
.br
\fI$humanFileSize\fP Whether to return the size in a human-readable format\&.
.RE
.PP
\fBReturns\fP
.RS 4
mixed The file size, either in bytes or as a formatted string\&. 
.RE
.PP

.PP
Definition at line \fB1352\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1353     {
1354         $size = 0;
1355 
1356         $data = get_headers($url, true);
1357         if (isset($data['Content\-Length'])) {
1358             $size = intval($data['Content\-Length']);
1359         }
1360 
1361         return $humanFileSize ? self::humanFileSize($size) : $size;
1362     }
.PP
.fi

.PP
References \fBhumanFileSize()\fP\&.
.SS "getStartupLnkPath ()\fR [static]\fP"
Retrieves the path for the startup link file\&.

.PP
\fBReturns\fP
.RS 4
string The full path to the startup link file\&. 
.RE
.PP

.PP
Definition at line \fB619\fP of file \fBclass\&.util\&.php\fP\&.
.nf
620     {
621         return Vbs::getStartupPath(APP_TITLE \&. '\&.lnk');
622     }
.PP
.fi

.PP
References \fBAPP_TITLE\fP, and \fBVbs\\getStartupPath()\fP\&.
.PP
Referenced by \fBdisableLaunchStartup()\fP\&.
.SS "getSysPathRegKey ()\fR [static]\fP"
Retrieves the system path from the registry\&.

.PP
\fBReturns\fP
.RS 4
mixed The value of the system path registry key or false on error\&. 
.RE
.PP

.PP
Definition at line \fB568\fP of file \fBclass\&.util\&.php\fP\&.
.nf
569     {
570         global $bearsamppRegistry;
571 
572         return $bearsamppRegistry\->getValue(
573             Registry::HKEY_LOCAL_MACHINE,
574             Registry::ENV_KEY,
575             Registry::SYSPATH_REG_ENTRY
576         );
577     }
.PP
.fi

.PP
References \fBRegistry\\ENV_KEY\fP, \fBRegistry\\HKEY_LOCAL_MACHINE\fP, and \fBRegistry\\SYSPATH_REG_ENTRY\fP\&.
.PP
Referenced by \fBActionStartup\\checkSystemPathRegKey()\fP\&.
.SS "getVersionList ( $path)\fR [static]\fP"
Retrieves a list of version directories within a specified path\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP The path to search for version directories\&.
.RE
.PP
\fBReturns\fP
.RS 4
array|false Returns a sorted array of version names, or false if the directory cannot be opened\&. 
.RE
.PP

.PP
Definition at line \fB418\fP of file \fBclass\&.util\&.php\fP\&.
.nf
419     {
420         $result = array();
421 
422         $handle = @opendir($path);
423         if (!$handle) {
424             return false;
425         }
426 
427         while (false !== ($file = readdir($handle))) {
428             $filePath = $path \&. '/' \&. $file;
429             if ($file != '\&.' && $file != '\&.\&.' && is_dir($filePath) && $file != 'current') {
430                 $result[] = str_replace(basename($path), '', $file);
431             }
432         }
433 
434         closedir($handle);
435         natcasesort($result);
436 
437         return $result;
438     }
.PP
.fi

.PP
References \fB$result\fP\&.
.PP
Referenced by \fBModule\\getVersionList()\fP\&.
.SS "getWebsiteUrl ( $path = \fR''\fP,  $fragment = \fR''\fP,  $utmSource = \fRtrue\fP)\fR [static]\fP"
Constructs a complete website URL with optional path, fragment, and UTM source parameters\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP Optional path to append to the base URL\&. 
.br
\fI$fragment\fP Optional fragment to append to the URL\&. 
.br
\fI$utmSource\fP Whether to include UTM source parameters\&.
.RE
.PP
\fBReturns\fP
.RS 4
string The constructed URL\&. 
.RE
.PP

.PP
Definition at line \fB1314\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1315     {
1316         global $bearsamppCore;
1317 
1318         $url = APP_WEBSITE;
1319         if (!empty($path)) {
1320             $url \&.= '/' \&. ltrim($path, '/');
1321         }
1322         if ($utmSource) {
1323             $url = rtrim($url, '/') \&. '/?utm_source=bearsampp\-' \&. $bearsamppCore\->getAppVersion();
1324         }
1325         if (!empty($fragment)) {
1326             $url \&.= $fragment;
1327         }
1328 
1329         return $url;
1330     }
.PP
.fi

.PP
References \fB$bearsamppCore\fP, and \fBAPP_WEBSITE\fP\&.
.PP
Referenced by \fBgetChangelogUrl()\fP, \fBTplAppApache\\getMenuApache()\fP, \fBTplAppMailpit\\getMenuMailpit()\fP, \fBTplAppMariadb\\getMenuMariadb()\fP, \fBTplAppMemcached\\getMenuMemcached()\fP, \fBTplAppMysql\\getMenuMysql()\fP, \fBTplAppNodejs\\getMenuNodejs()\fP, \fBTplAppPhp\\getMenuPhp()\fP, \fBTplAppPostgresql\\getMenuPostgresql()\fP, \fBTplAppXlight\\getMenuXlight()\fP, \fBQuickPick\\getQuickpickMenu()\fP, \fBTplApp\\getSectionMenuRight()\fP, \fBgetWebsiteUrlNoUtm()\fP, and \fBActionAbout\\processWindow()\fP\&.
.SS "getWebsiteUrlNoUtm ( $path = \fR''\fP,  $fragment = \fR''\fP)\fR [static]\fP"
Constructs a website URL without UTM parameters\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP Optional path to append to the base URL\&. 
.br
\fI$fragment\fP Optional fragment to append to the URL\&.
.RE
.PP
\fBReturns\fP
.RS 4
string The constructed URL without UTM parameters\&. 
.RE
.PP

.PP
Definition at line \fB1300\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1301     {
1302         return self::getWebsiteUrl($path, $fragment, false);
1303     }
.PP
.fi

.PP
References \fBgetWebsiteUrl()\fP\&.
.PP
Referenced by \fBActionAbout\\__construct()\fP\&.
.SS "humanFileSize ( $size,  $unit = \fR''\fP)\fR [static]\fP"
Converts a file size in bytes to a human-readable format\&.

.PP
\fBParameters\fP
.RS 4
\fI$size\fP The file size in bytes\&. 
.br
\fI$unit\fP The unit to convert to ('GB', 'MB', 'KB', or '')\&. If empty, auto-selects the unit\&.
.RE
.PP
\fBReturns\fP
.RS 4
string The formatted file size\&. 
.RE
.PP

.PP
Definition at line \fB1372\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1373     {
1374         if ((!$unit && $size >= 1 << 30) || $unit == 'GB') {
1375             return number_format($size / (1 << 30), 2) \&. 'GB';
1376         }
1377         if ((!$unit && $size >= 1 << 20) || $unit == 'MB') {
1378             return number_format($size / (1 << 20), 2) \&. 'MB';
1379         }
1380         if ((!$unit && $size >= 1 << 10) || $unit == 'KB') {
1381             return number_format($size / (1 << 10), 2) \&. 'KB';
1382         }
1383 
1384         return number_format($size) \&. ' bytes';
1385     }
.PP
.fi

.PP
Referenced by \fBgetRemoteFilesize()\fP\&.
.SS "imgToBase64 ( $path)\fR [static]\fP"
Converts an image file to a base64 encoded string\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP The path to the image file\&.
.RE
.PP
\fBReturns\fP
.RS 4
string Returns the base64 encoded string of the image\&. 
.RE
.PP

.PP
Definition at line \fB900\fP of file \fBclass\&.util\&.php\fP\&.
.nf
901     {
902         $type = pathinfo($path, PATHINFO_EXTENSION);
903         $data = file_get_contents($path);
904 
905         return 'data:image/' \&. $type \&. ';base64,' \&. base64_encode($data);
906     }
.PP
.fi

.SS "installService ( $bin,  $port,  $syntaxCheckCmd,  $showWindow = \fRfalse\fP)\fR [static]\fP"
Attempts to install and start a service on a specific port, with optional syntax checking and user notifications\&.

.PP
\fBParameters\fP
.RS 4
\fI$bin\fP An object containing the binary information and methods related to the service\&. 
.br
\fI$port\fP The port number on which the service should run\&. 
.br
\fI$syntaxCheckCmd\fP The command to execute for syntax checking of the service configuration\&. 
.br
\fI$showWindow\fP Optional\&. Whether to show message boxes for information, warnings, and errors\&. Defaults to false\&.
.RE
.PP
\fBReturns\fP
.RS 4
bool Returns true if the service is successfully installed and started, false otherwise\&. 
.RE
.PP

.PP
Definition at line \fB1648\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1649     {
1650         global $bearsamppLang, $bearsamppWinbinder;
1651         $name     = $bin\->getName();
1652         $service  = $bin\->getService();
1653         $boxTitle = sprintf($bearsamppLang\->getValue(Lang::INSTALL_SERVICE_TITLE), $name);
1654 
1655         $isPortInUse = self::isPortInUse($port);
1656         if ($isPortInUse === false) {
1657             if (!$service\->isInstalled()) {
1658                 $service\->create();
1659                 if ($service\->start()) {
1660                     self::logInfo(sprintf('%s service successfully installed\&. (name: %s ; port: %s)', $name, $service\->getName(), $port));
1661                     if ($showWindow) {
1662                         $bearsamppWinbinder\->messageBoxInfo(
1663                             sprintf($bearsamppLang\->getValue(Lang::SERVICE_INSTALLED), $name, $service\->getName(), $port),
1664                             $boxTitle
1665                         );
1666                     }
1667 
1668                     return true;
1669                 } else {
1670                     $serviceError    = sprintf($bearsamppLang\->getValue(Lang::SERVICE_INSTALL_ERROR), $name);
1671                     $serviceErrorLog = sprintf('Error during the installation of %s service', $name);
1672                     if (!empty($syntaxCheckCmd)) {
1673                         $cmdSyntaxCheck = $bin\->getCmdLineOutput($syntaxCheckCmd);
1674                         if (!$cmdSyntaxCheck['syntaxOk']) {
1675                             $serviceError    \&.= PHP_EOL \&. sprintf($bearsamppLang\->getValue(Lang::STARTUP_SERVICE_SYNTAX_ERROR), $cmdSyntaxCheck['content']);
1676                             $serviceErrorLog \&.= sprintf(' (conf errors detected : %s)', $cmdSyntaxCheck['content']);
1677                         }
1678                     }
1679                     self::logError($serviceErrorLog);
1680                     if ($showWindow) {
1681                         $bearsamppWinbinder\->messageBoxError($serviceError, $boxTitle);
1682                     }
1683                 }
1684             } else {
1685                 self::logWarning(sprintf('%s service already installed', $name));
1686                 if ($showWindow) {
1687                     $bearsamppWinbinder\->messageBoxWarning(
1688                         sprintf($bearsamppLang\->getValue(Lang::SERVICE_ALREADY_INSTALLED), $name),
1689                         $boxTitle
1690                     );
1691                 }
1692 
1693                 return true;
1694             }
1695         } elseif ($service\->isRunning()) {
1696             self::logWarning(sprintf('%s service already installed and running', $name));
1697             if ($showWindow) {
1698                 $bearsamppWinbinder\->messageBoxWarning(
1699                     sprintf($bearsamppLang\->getValue(Lang::SERVICE_ALREADY_INSTALLED), $name),
1700                     $boxTitle
1701                 );
1702             }
1703 
1704             return true;
1705         } else {
1706             self::logError(sprintf('Port %s is used by an other application : %s', $name));
1707             if ($showWindow) {
1708                 $bearsamppWinbinder\->messageBoxError(
1709                     sprintf($bearsamppLang\->getValue(Lang::PORT_NOT_USED_BY), $port, $isPortInUse),
1710                     $boxTitle
1711                 );
1712             }
1713         }
1714 
1715         return false;
1716     }
.PP
.fi

.PP
References \fB$bearsamppLang\fP, \fB$port\fP, \fBLang\\INSTALL_SERVICE_TITLE\fP, \fBisPortInUse()\fP, \fBlogError()\fP, \fBlogInfo()\fP, \fBlogWarning()\fP, \fBLang\\PORT_NOT_USED_BY\fP, \fBLang\\SERVICE_ALREADY_INSTALLED\fP, \fBLang\\SERVICE_INSTALL_ERROR\fP, \fBLang\\SERVICE_INSTALLED\fP, and \fBLang\\STARTUP_SERVICE_SYNTAX_ERROR\fP\&.
.PP
Referenced by \fBActionService\\install()\fP, \fBBinApache\\setEnable()\fP, \fBBinMailpit\\setEnable()\fP, \fBBinMariadb\\setEnable()\fP, \fBBinMemcached\\setEnable()\fP, \fBBinMysql\\setEnable()\fP, \fBBinPostgresql\\setEnable()\fP, and \fBBinXlight\\setEnable()\fP\&.
.SS "is32BitsOs ()\fR [static]\fP"
Checks if the operating system is 32-bit\&.

.PP
\fBReturns\fP
.RS 4
bool True if the OS is 32-bit, false otherwise\&. 
.RE
.PP

.PP
Definition at line \fB1392\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1393     {
1394         $processor = self::getProcessorRegKey();
1395 
1396         return self::contains($processor, 'x86');
1397     }
.PP
.fi

.PP
References \fBcontains()\fP, and \fBgetProcessorRegKey()\fP\&.
.SS "isAlphanumeric ( $string)\fR [static]\fP"
Checks if a string is alphanumeric\&.

.PP
\fBParameters\fP
.RS 4
\fI$string\fP The string to check\&.
.RE
.PP
\fBReturns\fP
.RS 4
bool Returns true if the string is alphanumeric, false otherwise\&. 
.RE
.PP

.PP
Definition at line \fB1633\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1634     {
1635         return ctype_alnum($string);
1636     }
.PP
.fi

.SS "isLaunchStartup ()\fR [static]\fP"
Checks if the application is set to launch at startup\&.

.PP
\fBReturns\fP
.RS 4
bool True if the startup link exists, false otherwise\&. 
.RE
.PP

.PP
Definition at line \fB629\fP of file \fBclass\&.util\&.php\fP\&.
.nf
630     {
631         return file_exists(self::getStartupLnkPath());
632     }
.PP
.fi

.PP
Referenced by \fBActionReload\\__construct()\fP, and \fBTplAppLaunchStartup\\process()\fP\&.
.SS "isPortInUse ( $port)\fR [static]\fP"
Checks if a specific port is in use\&.

.PP
\fBParameters\fP
.RS 4
\fI$port\fP The port number to check
.RE
.PP
\fBReturns\fP
.RS 4
mixed False if the port is not in use, otherwise returns the process using the port 
.RE
.PP

.PP
Definition at line \fB1586\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1587     {
1588         // Set localIP statically
1589         $localIP = '127\&.0\&.0\&.1';
1590 
1591         // Save current error reporting level
1592         $errorReporting = error_reporting();
1593 
1594         // Disable error reporting temporarily
1595         error_reporting(0);
1596 
1597         $connection = @fsockopen($localIP, $port);
1598 
1599         // Restore original error reporting level
1600         error_reporting($errorReporting);
1601 
1602         if (is_resource($connection)) {
1603             fclose($connection);
1604             $process = Batch::getProcessUsingPort($port);
1605 
1606             return $process != null ? $process : 'N/A';
1607         }
1608 
1609         return false;
1610     }
.PP
.fi

.PP
References \fB$port\fP, and \fBBatch\\getProcessUsingPort()\fP\&.
.PP
Referenced by \fBBinApache\\changePort()\fP, \fBBinMailpit\\changePort()\fP, \fBBinMariadb\\changePort()\fP, \fBBinMemcached\\changePort()\fP, \fBBinMysql\\changePort()\fP, \fBBinPostgresql\\changePort()\fP, \fBBinXlight\\changePort()\fP, \fBBinPostgresql\\handleNonPostgresUsage()\fP, \fBinstallService()\fP, and \fBActionStartup\\installServices()\fP\&.
.SS "isValidDomainName ( $domainName)\fR [static]\fP"
Validates a domain name based on specific criteria\&.

.PP
\fBParameters\fP
.RS 4
\fI$domainName\fP The domain name to validate\&.
.RE
.PP
\fBReturns\fP
.RS 4
bool Returns true if the domain name is valid, false otherwise\&. 
.RE
.PP

.PP
Definition at line \fB1619\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1620     {
1621         return preg_match('/^([a\-z\\d](\-*[a\-z\\d])*)(\\\&.([a\-z\\d](\-*[a\-z\\d])*))*$/i', $domainName)
1622             && preg_match('/^\&.{1,253}$/', $domainName)
1623             && preg_match('/^[^\\\&.]{1,63}(\\\&.[^\\\&.]{1,63})*$/', $domainName);
1624     }
.PP
.fi

.PP
Referenced by \fBActionAddVhost\\processWindow()\fP, and \fBActionEditVhost\\processWindow()\fP\&.
.SS "isValidIp ( $ip)\fR [static]\fP"
Validates an IP address\&.

.PP
\fBParameters\fP
.RS 4
\fI$ip\fP The IP address to validate\&.
.RE
.PP
\fBReturns\fP
.RS 4
bool Returns true if the IP address is valid, otherwise false\&. 
.RE
.PP

.PP
Definition at line \fB340\fP of file \fBclass\&.util\&.php\fP\&.
.nf
341     {
342         return filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)
343             || filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6);
344     }
.PP
.fi

.SS "isValidPort ( $port)\fR [static]\fP"
Validates a port number\&.

.PP
\fBParameters\fP
.RS 4
\fI$port\fP The port number to validate\&.
.RE
.PP
\fBReturns\fP
.RS 4
bool Returns true if the port number is valid and within the range of 1 to 65535, otherwise false\&. 
.RE
.PP

.PP
Definition at line \fB353\fP of file \fBclass\&.util\&.php\fP\&.
.nf
354     {
355         return is_numeric($port) && ($port > 0 && $port <= 65535);
356     }
.PP
.fi

.PP
References \fB$port\fP\&.
.PP
Referenced by \fBBinApache\\changePort()\fP, \fBBinMailpit\\changePort()\fP, \fBBinMariadb\\changePort()\fP, \fBBinMemcached\\changePort()\fP, \fBBinMysql\\changePort()\fP, \fBBinPostgresql\\changePort()\fP, \fBBinXlight\\changePort()\fP, \fBBinApache\\checkPort()\fP, \fBBinMailpit\\checkPort()\fP, \fBBinMariadb\\checkPort()\fP, \fBBinMemcached\\checkPort()\fP, \fBBinMysql\\checkPort()\fP, \fBBinPostgresql\\checkPort()\fP, and \fBBinXlight\\checkPort()\fP\&.
.SS "log ( $data,  $type,  $file = \fRnull\fP)\fR [static]\fP, \fR [private]\fP"
Logs a message to a specified file or default log file based on the log type\&.

.PP
\fBParameters\fP
.RS 4
\fI$data\fP The message to log\&. 
.br
\fI$type\fP The type of log message: 'ERROR', 'WARNING', 'INFO', 'DEBUG', or 'TRACE'\&. 
.br
\fI$file\fP The file path to write the log message to\&. If null, uses default log file based on type\&. 
.RE
.PP

.PP
Definition at line \fB669\fP of file \fBclass\&.util\&.php\fP\&.
.nf
670     {
671         global $bearsamppRoot, $bearsamppCore, $bearsamppConfig;
672         $file = $file == null ? ($type == self::LOG_ERROR ? $bearsamppRoot\->getErrorLogFilePath() : $bearsamppRoot\->getLogFilePath()) : $file;
673         if (!$bearsamppRoot\->isRoot()) {
674             $file = $bearsamppRoot\->getHomepageLogFilePath();
675         }
676 
677         $verbose                         = array();
678         $verbose[Config::VERBOSE_SIMPLE] = $type == self::LOG_ERROR || $type == self::LOG_WARNING;
679         $verbose[Config::VERBOSE_REPORT] = $verbose[Config::VERBOSE_SIMPLE] || $type == self::LOG_INFO;
680         $verbose[Config::VERBOSE_DEBUG]  = $verbose[Config::VERBOSE_REPORT] || $type == self::LOG_DEBUG;
681         $verbose[Config::VERBOSE_TRACE]  = $verbose[Config::VERBOSE_DEBUG] || $type == self::LOG_TRACE;
682 
683         $writeLog = false;
684         if ($bearsamppConfig\->getLogsVerbose() == Config::VERBOSE_SIMPLE && $verbose[Config::VERBOSE_SIMPLE]) {
685             $writeLog = true;
686         } elseif ($bearsamppConfig\->getLogsVerbose() == Config::VERBOSE_REPORT && $verbose[Config::VERBOSE_REPORT]) {
687             $writeLog = true;
688         } elseif ($bearsamppConfig\->getLogsVerbose() == Config::VERBOSE_DEBUG && $verbose[Config::VERBOSE_DEBUG]) {
689             $writeLog = true;
690         } elseif ($bearsamppConfig\->getLogsVerbose() == Config::VERBOSE_TRACE && $verbose[Config::VERBOSE_TRACE]) {
691             $writeLog = true;
692         }
693 
694         if ($writeLog) {
695             file_put_contents(
696                 $file,
697                 '[' \&. date('Y\-m\-d H:i:s', time()) \&. '] # ' \&. APP_TITLE \&. ' ' \&. $bearsamppCore\->getAppVersion() \&. ' # ' \&. $type \&. ': ' \&. $data \&. PHP_EOL,
698                 FILE_APPEND
699             );
700         }
701     }
.PP
.fi

.PP
References \fB$bearsamppConfig\fP, \fB$bearsamppCore\fP, \fB$bearsamppRoot\fP, \fBAPP_TITLE\fP, \fBConfig\\VERBOSE_DEBUG\fP, \fBConfig\\VERBOSE_REPORT\fP, \fBConfig\\VERBOSE_SIMPLE\fP, and \fBConfig\\VERBOSE_TRACE\fP\&.
.PP
Referenced by \fBlogDebug()\fP, \fBlogError()\fP, \fBlogInfo()\fP, \fBlogTrace()\fP, and \fBlogWarning()\fP\&.
.SS "logDebug ( $data,  $file = \fRnull\fP)\fR [static]\fP"
Logs debug information\&. This function is a wrapper around the generic log function for debug-level messages\&.

.PP
\fBParameters\fP
.RS 4
\fI$data\fP The data to log\&. 
.br
\fI$file\fP Optional\&. The file path to log to\&. If not provided, a default path is used\&. 
.RE
.PP

.PP
Definition at line \fB755\fP of file \fBclass\&.util\&.php\fP\&.
.nf
756     {
757         self::log($data, self::LOG_DEBUG, $file);
758     }
.PP
.fi

.PP
References \fBlog()\fP\&.
.PP
Referenced by \fBAction\\call()\fP, \fBBinApache\\changePort()\fP, \fBBinMailpit\\changePort()\fP, \fBBinMariadb\\changePort()\fP, \fBBinMemcached\\changePort()\fP, \fBBinMysql\\changePort()\fP, \fBBinPostgresql\\changePort()\fP, \fBBinXlight\\changePort()\fP, \fBQuickPick\\checkDownloadId()\fP, \fBBinApache\\checkPort()\fP, \fBBinMailpit\\checkPort()\fP, \fBBinMariadb\\checkPort()\fP, \fBBinMemcached\\checkPort()\fP, \fBBinMysql\\checkPort()\fP, \fBBinPostgresql\\checkPort()\fP, \fBBinXlight\\checkPort()\fP, \fBdecryptFile()\fP, \fBSymlinks\\deleteCurrentSymlinks()\fP, \fBQuickPick\\fetchAndUnzipModule()\fP, \fBgetAppBinsRegKey()\fP, \fBgetFilesToScan()\fP, \fBgetHeaders()\fP, \fBgetHttpHeaders()\fP, \fBgetLatestVersion()\fP, \fBQuickPick\\getModuleUrl()\fP, \fBQuickPick\\getVersions()\fP, \fBBinPostgresql\\handleNonPostgresUsage()\fP, \fBQuickPick\\installModule()\fP, \fBVbs\\killProc()\fP, \fBQuickPick\\logHeaders()\fP, \fBAction\\process()\fP, \fBQuickPick\\rebuildQuickpickJson()\fP, \fBBinApache\\refreshAlias()\fP, \fBBinApache\\refreshConf()\fP, \fBBinApache\\refreshVhosts()\fP, \fBBinApache\\setEnable()\fP, \fBBinMailpit\\setEnable()\fP, \fBBinMariadb\\setEnable()\fP, \fBBinMemcached\\setEnable()\fP, \fBBinMysql\\setEnable()\fP, \fBBinNodejs\\setEnable()\fP, \fBBinPhp\\setEnable()\fP, \fBBinPostgresql\\setEnable()\fP, \fBBinXlight\\setEnable()\fP, \fBWin32Service\\start()\fP, \fBBinApache\\switchVersion()\fP, \fBBinMailpit\\switchVersion()\fP, \fBBinMariadb\\switchVersion()\fP, \fBBinMemcached\\switchVersion()\fP, \fBBinMysql\\switchVersion()\fP, \fBBinNodejs\\switchVersion()\fP, \fBBinPhp\\switchVersion()\fP, \fBBinPostgresql\\switchVersion()\fP, \fBBinXlight\\switchVersion()\fP, \fBCore\\unzipFile()\fP, \fBAppPhpmyadmin\\updateConfig()\fP, \fBAppPhppgadmin\\updateConfig()\fP, \fBBinApache\\updateConfig()\fP, \fBBinMailpit\\updateConfig()\fP, \fBBinMariadb\\updateConfig()\fP, \fBBinMemcached\\updateConfig()\fP, \fBBinMysql\\updateConfig()\fP, \fBBinNodejs\\updateConfig()\fP, \fBBinPhp\\updateConfig()\fP, \fBBinPostgresql\\updateConfig()\fP, \fBBinXlight\\updateConfig()\fP, \fBModule\\updateConfig()\fP, \fBToolGit\\updateConfig()\fP, \fBActionStartup\\writeLog()\fP, \fBBatch\\writeLog()\fP, \fBNssm\\writeLog()\fP, \fBRegistry\\writeLog()\fP, \fBVbs\\writeLog()\fP, \fBWin32Service\\writeLog()\fP, and \fBWinBinder\\writeLog()\fP\&.
.SS "logError ( $data,  $file = \fRnull\fP)\fR [static]\fP"
Logs error messages\&. This function is a wrapper around the generic log function for error-level messages\&.

.PP
\fBParameters\fP
.RS 4
\fI$data\fP The data to log\&. 
.br
\fI$file\fP Optional\&. The file path to log to\&. If not provided, a default path is used\&. 
.RE
.PP

.PP
Definition at line \fB791\fP of file \fBclass\&.util\&.php\fP\&.
.nf
792     {
793         self::log($data, self::LOG_ERROR, $file);
794     }
.PP
.fi

.PP
References \fBlog()\fP\&.
.PP
Referenced by \fBBinApache\\changePort()\fP, \fBBinMailpit\\changePort()\fP, \fBBinMariadb\\changePort()\fP, \fBBinMemcached\\changePort()\fP, \fBBinMysql\\changePort()\fP, \fBBinPostgresql\\changePort()\fP, \fBBinXlight\\changePort()\fP, \fBQuickPick\\checkDownloadId()\fP, \fBBinApache\\checkPort()\fP, \fBBinMailpit\\checkPort()\fP, \fBBinMariadb\\checkPort()\fP, \fBBinMemcached\\checkPort()\fP, \fBBinMysql\\checkPort()\fP, \fBBinPostgresql\\checkPort()\fP, \fBBinXlight\\checkPort()\fP, \fBVbs\\createShortcut()\fP, \fBModule\\createSymlink()\fP, \fBSymlinks\\deleteCurrentSymlinks()\fP, \fBQuickPick\\fetchAndUnzipModule()\fP, \fBgetApiJson()\fP, \fBCore\\getAppVersion()\fP, \fBCore\\getFileFromUrl()\fP, \fBgetLatestVersion()\fP, \fBQuickPick\\getModuleUrl()\fP, \fBQuickPick\\getQuickpickJson()\fP, \fBQuickPick\\getVersions()\fP, \fBQuickPick\\installModule()\fP, \fBinstallService()\fP, \fBActionCheckVersion\\processWindow()\fP, \fBAppPhpmyadmin\\reload()\fP, \fBAppPhppgadmin\\reload()\fP, \fBBinApache\\reload()\fP, \fBBinMailpit\\reload()\fP, \fBBinMariadb\\reload()\fP, \fBBinMemcached\\reload()\fP, \fBBinMysql\\reload()\fP, \fBBinNodejs\\reload()\fP, \fBBinPhp\\reload()\fP, \fBBinPostgresql\\reload()\fP, \fBBinXlight\\reload()\fP, \fBToolBruno\\reload()\fP, \fBToolComposer\\reload()\fP, \fBToolConsoleZ\\reload()\fP, \fBToolGhostscript\\reload()\fP, \fBToolGit\\reload()\fP, \fBToolNgrok\\reload()\fP, \fBToolPerl\\reload()\fP, \fBToolPython\\reload()\fP, \fBToolRuby\\reload()\fP, \fBremoveService()\fP, \fBWin32Service\\start()\fP, \fBstartService()\fP, \fBTplAppReload\\triggerReload()\fP, \fBCore\\unzipFile()\fP, \fBAppPhpmyadmin\\updateConfig()\fP, \fBAppPhppgadmin\\updateConfig()\fP, \fBBinApache\\updateConfig()\fP, \fBBinMailpit\\updateConfig()\fP, \fBBinMariadb\\updateConfig()\fP, \fBBinMemcached\\updateConfig()\fP, \fBBinMysql\\updateConfig()\fP, \fBBinNodejs\\updateConfig()\fP, \fBBinPhp\\updateConfig()\fP, \fBBinPostgresql\\updateConfig()\fP, \fBBinXlight\\updateConfig()\fP, and \fBNssm\\writeLogError()\fP\&.
.SS "logInfo ( $data,  $file = \fRnull\fP)\fR [static]\fP"
Logs informational messages\&. This function is a wrapper around the generic log function for informational messages\&.

.PP
\fBParameters\fP
.RS 4
\fI$data\fP The data to log\&. 
.br
\fI$file\fP Optional\&. The file path to log to\&. If not provided, a default path is used\&. 
.RE
.PP

.PP
Definition at line \fB767\fP of file \fBclass\&.util\&.php\fP\&.
.nf
768     {
769         self::log($data, self::LOG_INFO, $file);
770     }
.PP
.fi

.PP
References \fBlog()\fP\&.
.PP
Referenced by \fBBatch\\exitApp()\fP, \fBinstallService()\fP, \fBAppPhpmyadmin\\reload()\fP, \fBAppPhppgadmin\\reload()\fP, \fBBinApache\\reload()\fP, \fBBinMailpit\\reload()\fP, \fBBinMariadb\\reload()\fP, \fBBinMemcached\\reload()\fP, \fBBinMysql\\reload()\fP, \fBBinNodejs\\reload()\fP, \fBBinPhp\\reload()\fP, \fBBinPostgresql\\reload()\fP, \fBBins\\reload()\fP, \fBBinXlight\\reload()\fP, \fBToolBruno\\reload()\fP, \fBToolComposer\\reload()\fP, \fBToolConsoleZ\\reload()\fP, \fBToolGhostscript\\reload()\fP, \fBToolGit\\reload()\fP, \fBToolNgrok\\reload()\fP, \fBToolPerl\\reload()\fP, \fBToolPython\\reload()\fP, \fBToolRuby\\reload()\fP, \fBremoveService()\fP, \fBBinApache\\setEnable()\fP, \fBBinMailpit\\setEnable()\fP, \fBBinMariadb\\setEnable()\fP, \fBBinMemcached\\setEnable()\fP, \fBBinMysql\\setEnable()\fP, \fBBinNodejs\\setEnable()\fP, \fBBinPhp\\setEnable()\fP, \fBBinPostgresql\\setEnable()\fP, \fBBinXlight\\setEnable()\fP, \fBWin32Service\\start()\fP, \fBApps\\update()\fP, \fBBins\\update()\fP, \fBTools\\update()\fP, and \fBNssm\\writeLogInfo()\fP\&.
.SS "logInitClass ( $classInstance)\fR [static]\fP"
Logs the initialization of a class instance\&.

.PP
\fBParameters\fP
.RS 4
\fI$classInstance\fP The instance of the class to log\&. 
.RE
.PP

.PP
Definition at line \fB801\fP of file \fBclass\&.util\&.php\fP\&.
.nf
802     {
803         self::logTrace('Init ' \&. get_class($classInstance));
804     }
.PP
.fi

.PP
References \fBlogTrace()\fP\&.
.PP
Referenced by \fBAppPhpmyadmin\\__construct()\fP, \fBAppPhppgadmin\\__construct()\fP, \fBBinApache\\__construct()\fP, \fBBinMailpit\\__construct()\fP, \fBBinMariadb\\__construct()\fP, \fBBinMemcached\\__construct()\fP, \fBBinMysql\\__construct()\fP, \fBBinNodejs\\__construct()\fP, \fBBinPhp\\__construct()\fP, \fBBinPostgresql\\__construct()\fP, \fBBins\\__construct()\fP, \fBBinXlight\\__construct()\fP, \fBHomepage\\__construct()\fP, \fBNssm\\__construct()\fP, \fBRegistry\\__construct()\fP, \fBSplash\\__construct()\fP, \fBToolBruno\\__construct()\fP, \fBToolComposer\\__construct()\fP, \fBToolConsoleZ\\__construct()\fP, \fBToolGhostscript\\__construct()\fP, \fBToolGit\\__construct()\fP, \fBToolNgrok\\__construct()\fP, \fBToolPerl\\__construct()\fP, \fBToolPython\\__construct()\fP, \fBToolRuby\\__construct()\fP, \fBWin32Service\\__construct()\fP, and \fBWinBinder\\__construct()\fP\&.
.SS "logReloadClass ( $classInstance)\fR [static]\fP"
Logs the reloading of a class instance\&.

.PP
\fBParameters\fP
.RS 4
\fI$classInstance\fP The instance of the class to log\&. 
.RE
.PP

.PP
Definition at line \fB811\fP of file \fBclass\&.util\&.php\fP\&.
.nf
812     {
813         self::logTrace('Reload ' \&. get_class($classInstance));
814     }
.PP
.fi

.PP
References \fBlogTrace()\fP\&.
.PP
Referenced by \fBAppPhpmyadmin\\reload()\fP, \fBAppPhppgadmin\\reload()\fP, \fBBinApache\\reload()\fP, \fBBinMailpit\\reload()\fP, \fBBinMariadb\\reload()\fP, \fBBinMemcached\\reload()\fP, \fBBinMysql\\reload()\fP, \fBBinNodejs\\reload()\fP, \fBBinPhp\\reload()\fP, \fBBinPostgresql\\reload()\fP, \fBBinXlight\\reload()\fP, \fBToolBruno\\reload()\fP, \fBToolComposer\\reload()\fP, \fBToolConsoleZ\\reload()\fP, \fBToolGhostscript\\reload()\fP, \fBToolGit\\reload()\fP, \fBToolNgrok\\reload()\fP, \fBToolPerl\\reload()\fP, \fBToolPython\\reload()\fP, and \fBToolRuby\\reload()\fP\&.
.SS "logSeparator ()\fR [static]\fP"
Appends a separator line to multiple log files if they do not already end with it\&. This function ensures that each log file ends with a clear separator for better readability\&.

.PP
@global object $bearsamppRoot An object that provides paths to various log files\&. 
.PP
Definition at line \fB709\fP of file \fBclass\&.util\&.php\fP\&.
.nf
710     {
711         global $bearsamppRoot;
712 
713         $logs = array(
714             $bearsamppRoot\->getLogFilePath(),
715             $bearsamppRoot\->getErrorLogFilePath(),
716             $bearsamppRoot\->getServicesLogFilePath(),
717             $bearsamppRoot\->getRegistryLogFilePath(),
718             $bearsamppRoot\->getStartupLogFilePath(),
719             $bearsamppRoot\->getBatchLogFilePath(),
720             $bearsamppRoot\->getVbsLogFilePath(),
721             $bearsamppRoot\->getWinbinderLogFilePath(),
722         );
723 
724         $separator = '========================================================================================' \&. PHP_EOL;
725         foreach ($logs as $log) {
726             if (!file_exists($log)) {
727                 continue; // Skip to the next iteration if the file does not exist
728             }
729             $logContent = @file_get_contents($log);
730             if ($logContent !== false && !self::endWith($logContent, $separator)) {
731                 file_put_contents($log, $separator, FILE_APPEND);
732             }
733         }
734     }
.PP
.fi

.PP
References \fB$bearsamppRoot\fP\&.
.PP
Referenced by \fBRoot\\register()\fP\&.
.SS "logTrace ( $data,  $file = \fRnull\fP)\fR [static]\fP"
Logs trace information\&. This function is a wrapper around the generic log function for trace-level messages\&.

.PP
\fBParameters\fP
.RS 4
\fI$data\fP The data to log\&. 
.br
\fI$file\fP Optional\&. The file path to log to\&. If not provided, a default path is used\&. 
.RE
.PP

.PP
Definition at line \fB743\fP of file \fBclass\&.util\&.php\fP\&.
.nf
744     {
745         self::log($data, self::LOG_TRACE, $file);
746     }
.PP
.fi

.PP
References \fBlog()\fP\&.
.PP
Referenced by \fBActionExec\\__construct()\fP, \fBActionManualRestart\\__construct()\fP, \fBActionRebuildini\\__construct()\fP, \fBWin32Service\\callWin32Service()\fP, \fBBinMysql\\changeRootPassword()\fP, \fBActionLoading\\checkAllServicesStarted()\fP, \fBActionStartup\\checkApacheServiceWithTimeout()\fP, \fBActionStartup\\checkMySQLServiceWithTimeout()\fP, \fBBinMysql\\checkPort()\fP, \fBBinMysql\\checkRootPassword()\fP, \fBWin32Service\\create()\fP, \fBOpenSsl\\createCrt()\fP, \fBWin32Service\\delete()\fP, \fBgetCurlHttpHeaders()\fP, \fBWin32Service\\infos()\fP, \fBBinMysql\\initData()\fP, \fBActionStartup\\installServices()\fP, \fBWin32Service\\isInstalled()\fP, \fBWin32Service\\isPaused()\fP, \fBWin32Service\\isPending()\fP, \fBWin32Service\\isRunning()\fP, \fBWin32Service\\isStopped()\fP, \fBlogInitClass()\fP, \fBlogReloadClass()\fP, \fBActionLoading\\processLoading()\fP, \fBActionStartup\\processWindow()\fP, \fBActionSwitchVersion\\processWindow()\fP, \fBBinMailpit\\rebuildConf()\fP, \fBBinApache\\refreshAlias()\fP, \fBBinApache\\refreshConf()\fP, \fBBinApache\\refreshVhosts()\fP, \fBConfig\\replaceAll()\fP, \fBreplaceInFile()\fP, \fBActionStartup\\rotationLogs()\fP, \fBBinPhp\\setVersion()\fP, \fBWin32Service\\status()\fP, \fBWin32Service\\stop()\fP, \fBActionQuit\\terminatePhpProcesses()\fP, \fBTplAppReload\\triggerReload()\fP, \fBCore\\unzipFile()\fP, \fBBinPhp\\updateConfig()\fP, and \fBActionSwitchVersion\\updateConfigVersion()\fP\&.
.SS "logWarning ( $data,  $file = \fRnull\fP)\fR [static]\fP"
Logs warning messages\&. This function is a wrapper around the generic log function for warning-level messages\&.

.PP
\fBParameters\fP
.RS 4
\fI$data\fP The data to log\&. 
.br
\fI$file\fP Optional\&. The file path to log to\&. If not provided, a default path is used\&. 
.RE
.PP

.PP
Definition at line \fB779\fP of file \fBclass\&.util\&.php\fP\&.
.nf
780     {
781         self::log($data, self::LOG_WARNING, $file);
782     }
.PP
.fi

.PP
References \fBlog()\fP\&.
.PP
Referenced by \fBgetNssmEnvPaths()\fP, \fBBatch\\initializeMysql()\fP, \fBBatch\\initializePostgresql()\fP, \fBinstallService()\fP, \fBToolGit\\reload()\fP, and \fBremoveService()\fP\&.
.SS "openFileContent ( $caption,  $content)\fR [static]\fP"
Opens a file with a given caption and content in the default text editor\&. The file is created in a temporary directory with a unique name\&.

.PP
\fBParameters\fP
.RS 4
\fI$caption\fP The filename to use when saving the content\&. 
.br
\fI$content\fP The content to write to the file\&.
.RE
.PP
@global object $bearsamppRoot Global object to access temporary path\&. @global object $bearsamppConfig Global configuration object\&. @global object $bearsamppWinbinder Global object to execute external programs\&. 
.PP
Definition at line \fB1902\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1903     {
1904         global $bearsamppRoot, $bearsamppConfig, $bearsamppWinbinder;
1905 
1906         $folderPath = $bearsamppRoot\->getTmpPath() \&. '/openFileContent\-' \&. self::random();
1907         if (!is_dir($folderPath)) {
1908             mkdir($folderPath, 0777, true);
1909         }
1910 
1911         $filepath = self::formatWindowsPath($folderPath \&. '/' \&. $caption);
1912         file_put_contents($filepath, $content);
1913 
1914         $bearsamppWinbinder\->exec($bearsamppConfig\->getNotepad(), '"' \&. $filepath \&. '"');
1915     }
.PP
.fi

.PP
References \fB$bearsamppConfig\fP, \fB$bearsamppRoot\fP, \fBformatWindowsPath()\fP, and \fBrandom()\fP\&.
.PP
Referenced by \fBActionDebugApache\\__construct()\fP, \fBActionDebugMariadb\\__construct()\fP, \fBActionDebugMysql\\__construct()\fP, and \fBActionDebugPostgresql\\__construct()\fP\&.
.SS "random ( $length = \fR32\fP,  $withNumeric = \fRtrue\fP)\fR [static]\fP"
Generates a random string of specified length and character set\&.

.PP
\fBParameters\fP
.RS 4
\fI$length\fP The length of the random string to generate\&. 
.br
\fI$withNumeric\fP Whether to include numeric characters in the random string\&.
.RE
.PP
\fBReturns\fP
.RS 4
string Returns the generated random string\&. 
.RE
.PP

.PP
Definition at line \fB193\fP of file \fBclass\&.util\&.php\fP\&.
.nf
194     {
195         $characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
196         if ($withNumeric) {
197             $characters \&.= '0123456789';
198         }
199 
200         $randomString = '';
201         for ($i = 0; $i < $length; $i++) {
202             $randomString \&.= $characters[rand(0, strlen($characters) \- 1)];
203         }
204 
205         return $randomString;
206     }
.PP
.fi

.PP
Referenced by \fBOpenSsl\\createCrt()\fP, \fBBatch\\getTmpFile()\fP, and \fBopenFileContent()\fP\&.
.SS "removeService ( $service,  $name)\fR [static]\fP"
Removes a service if it is installed\&.

.PP
\fBParameters\fP
.RS 4
\fI$service\fP The service object to be removed\&. 
.br
\fI$name\fP The name of the service\&.
.RE
.PP
\fBReturns\fP
.RS 4
bool Returns true if the service is successfully removed, false otherwise\&. 
.RE
.PP

.PP
Definition at line \fB1726\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1727     {
1728         if (!($service instanceof Win32Service)) {
1729             self::logError('$service not an instance of Win32Service');
1730 
1731             return false;
1732         }
1733 
1734         if ($service\->isInstalled()) {
1735             if ($service\->delete()) {
1736                 self::logInfo(sprintf('%s service successfully removed', $name));
1737 
1738                 return true;
1739             } else {
1740                 self::logError(sprintf('Error during the uninstallation of %s service', $name));
1741 
1742                 return false;
1743             }
1744         } else {
1745             self::logWarning(sprintf('%s service does not exist', $name));
1746         }
1747 
1748         return true;
1749     }
.PP
.fi

.PP
References \fBlogError()\fP, \fBlogInfo()\fP, and \fBlogWarning()\fP\&.
.PP
Referenced by \fBActionService\\remove()\fP, \fBBinApache\\setEnable()\fP, \fBBinMailpit\\setEnable()\fP, \fBBinMariadb\\setEnable()\fP, \fBBinMemcached\\setEnable()\fP, \fBBinMysql\\setEnable()\fP, \fBBinPostgresql\\setEnable()\fP, and \fBBinXlight\\setEnable()\fP\&.
.SS "replaceDefine ( $path,  $var,  $value)\fR [static]\fP"
Replaces a defined constant in a file with a new value\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP The file path where the constant is defined\&. 
.br
\fI$var\fP The name of the constant\&. 
.br
\fI$value\fP The new value for the constant\&. 
.RE
.PP

.PP
Definition at line \fB365\fP of file \fBclass\&.util\&.php\fP\&.
.nf
366     {
367         self::replaceInFile($path, array(
368             '/^define\\((\&.*?)' \&. $var \&. '(\&.*?),/' => 'define(\\'' \&. $var \&. '\\', ' \&. (is_int($value) ? $value : '\\'' \&. $value \&. '\\'') \&. ');'
369         ));
370     }
.PP
.fi

.PP
References \fBreplaceInFile()\fP\&.
.SS "replaceInFile ( $path,  $replaceList)\fR [static]\fP"
Performs replacements in a file based on a list of regular expression patterns\&.

.PP
\fBParameters\fP
.RS 4
\fI$path\fP The path to the file where replacements are to be made\&. 
.br
\fI$replaceList\fP An associative array where keys are regex patterns and values are replacement strings\&. 
.RE
.PP

.PP
Definition at line \fB378\fP of file \fBclass\&.util\&.php\fP\&.
.nf
379     {
380         if (file_exists($path)) {
381             $lines = file($path);
382             $fp    = fopen($path, 'w');
383             foreach ($lines as $nb => $line) {
384                 $replaceDone = false;
385                 foreach ($replaceList as $regex => $replace) {
386                     if (preg_match($regex, $line, $matches)) {
387                         $countParams = preg_match_all('/{{(\\d+)}}/', $replace, $paramsMatches);
388                         if ($countParams > 0 && $countParams <= count($matches)) {
389                             foreach ($paramsMatches[1] as $paramsMatch) {
390                                 $replace = str_replace('{{' \&. $paramsMatch \&. '}}', $matches[$paramsMatch], $replace);
391                             }
392                         }
393                         self::logTrace('Replace in file ' \&. $path \&. ' :');
394                         self::logTrace('## line_num: ' \&. trim($nb));
395                         self::logTrace('## old: ' \&. trim($line));
396                         self::logTrace('## new: ' \&. trim($replace));
397                         fwrite($fp, $replace \&. PHP_EOL);
398 
399                         $replaceDone = true;
400                         break;
401                     }
402                 }
403                 if (!$replaceDone) {
404                     fwrite($fp, $line);
405                 }
406             }
407             fclose($fp);
408         }
409     }
.PP
.fi

.PP
References \fBlogTrace()\fP\&.
.PP
Referenced by \fBBinPostgresql\\rebuildConf()\fP, \fBHomepage\\refreshCommonsJsContent()\fP, \fBreplaceDefine()\fP, \fBToolGit\\setScanStartup()\fP, \fBAppPhpmyadmin\\updateConfig()\fP, \fBAppPhppgadmin\\updateConfig()\fP, \fBBinApache\\updateConfig()\fP, \fBBinMariadb\\updateConfig()\fP, \fBBinMysql\\updateConfig()\fP, \fBBinPhp\\updateConfig()\fP, and \fBBinPostgresql\\updateConfig()\fP\&.
.SS "setAppBinsRegKey ( $value)\fR [static]\fP"
Retrieves or generates the application binaries registry key\&.

.PP
\fBParameters\fP
.RS 4
\fI$fromRegistry\fP Determines whether to retrieve the key from the registry or generate it\&.
.RE
.PP
\fBReturns\fP
.RS 4
string Returns the application binaries registry key\&. 
.RE
.PP

.PP
Definition at line \fB516\fP of file \fBclass\&.util\&.php\fP\&.
.nf
517     {
518         global $bearsamppRegistry;
519 
520         return $bearsamppRegistry\->setStringValue(
521             Registry::HKEY_LOCAL_MACHINE,
522             Registry::ENV_KEY,
523             Registry::APP_BINS_REG_ENTRY,
524             $value
525         );
526     }
.PP
.fi

.PP
References \fBRegistry\\APP_BINS_REG_ENTRY\fP, \fBRegistry\\ENV_KEY\fP, and \fBRegistry\\HKEY_LOCAL_MACHINE\fP\&.
.PP
Referenced by \fBActionStartup\\checkBinsRegKey()\fP, and \fBActionSwitchVersion\\processWindow()\fP\&.
.SS "setAppPathRegKey ( $value)\fR [static]\fP"
Sets the application path in the registry\&.

.PP
\fBParameters\fP
.RS 4
\fI$value\fP The new value for the application path\&.
.RE
.PP
\fBReturns\fP
.RS 4
bool True on success, false on failure\&. 
.RE
.PP

.PP
Definition at line \fB551\fP of file \fBclass\&.util\&.php\fP\&.
.nf
552     {
553         global $bearsamppRegistry;
554 
555         return $bearsamppRegistry\->setStringValue(
556             Registry::HKEY_LOCAL_MACHINE,
557             Registry::ENV_KEY,
558             Registry::APP_PATH_REG_ENTRY,
559             $value
560         );
561     }
.PP
.fi

.PP
References \fBRegistry\\APP_PATH_REG_ENTRY\fP, \fBRegistry\\ENV_KEY\fP, and \fBRegistry\\HKEY_LOCAL_MACHINE\fP\&.
.PP
Referenced by \fBActionStartup\\checkPathRegKey()\fP\&.
.SS "setSysPathRegKey ( $value)\fR [static]\fP"
Sets the system path in the registry\&.

.PP
\fBParameters\fP
.RS 4
\fI$value\fP The new value for the system path\&.
.RE
.PP
\fBReturns\fP
.RS 4
bool True on success, false on failure\&. 
.RE
.PP

.PP
Definition at line \fB586\fP of file \fBclass\&.util\&.php\fP\&.
.nf
587     {
588         global $bearsamppRegistry;
589 
590         return $bearsamppRegistry\->setExpandStringValue(
591             Registry::HKEY_LOCAL_MACHINE,
592             Registry::ENV_KEY,
593             Registry::SYSPATH_REG_ENTRY,
594             $value
595         );
596     }
.PP
.fi

.PP
References \fBRegistry\\ENV_KEY\fP, \fBRegistry\\HKEY_LOCAL_MACHINE\fP, and \fBRegistry\\SYSPATH_REG_ENTRY\fP\&.
.PP
Referenced by \fBActionStartup\\checkSystemPathRegKey()\fP\&.
.SS "setupCurlHeaderWithToken ()\fR [static]\fP"
Sets up a cURL header array using a decrypted GitHub Personal Access Token\&.

.PP
\fBReturns\fP
.RS 4
array The header array for cURL with authorization and other necessary details\&. 
.RE
.PP

.PP
Definition at line \fB1977\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1978     {
1979         // Usage
1980         global $bearsamppCore, $bearsamppConfig;
1981         $Token = self::decryptFile();
1982 
1983         return [
1984             'Accept: application/vnd\&.github+json',
1985             'Authorization: Token ' \&. $Token,
1986             'User\-Agent: ' \&. APP_GITHUB_USERAGENT,
1987             'X\-GitHub\-Api\-Version: 2022\-11\-28'
1988         ];
1989     }
.PP
.fi

.PP
References \fB$bearsamppConfig\fP, \fB$bearsamppCore\fP, \fBAPP_GITHUB_USERAGENT\fP, and \fBdecryptFile()\fP\&.
.PP
Referenced by \fBgetApiJson()\fP\&.
.SS "startLoading ()\fR [static]\fP"
Initiates a loading process using external components\&. 
.PP
Definition at line \fB935\fP of file \fBclass\&.util\&.php\fP\&.
.nf
936     {
937         global $bearsamppCore, $bearsamppWinbinder;
938         $bearsamppWinbinder\->exec($bearsamppCore\->getPhpExe(), Core::isRoot_FILE \&. ' ' \&. Action::LOADING);
939     }
.PP
.fi

.PP
References \fB$bearsamppCore\fP, \fBCore\\isRoot_FILE\fP, and \fBAction\\LOADING\fP\&.
.PP
Referenced by \fBActionCheckVersion\\__construct()\fP, \fBActionEnable\\__construct()\fP, \fBActionLaunchStartup\\__construct()\fP, \fBActionManualRestart\\__construct()\fP, \fBActionRefreshRepos\\__construct()\fP, \fBActionReload\\__construct()\fP, \fBActionService\\__construct()\fP, \fBActionSwitchOnline\\__construct()\fP, and \fBActionStartup\\processWindow()\fP\&.
.SS "startService ( $bin,  $syntaxCheckCmd,  $showWindow = \fRfalse\fP)\fR [static]\fP"
Attempts to start a service and performs a syntax check if required\&.

.PP
\fBParameters\fP
.RS 4
\fI$bin\fP An object containing service details\&. 
.br
\fI$syntaxCheckCmd\fP Command to check syntax errors\&. 
.br
\fI$showWindow\fP Whether to show error messages in a window\&.
.RE
.PP
\fBReturns\fP
.RS 4
bool Returns true if the service starts successfully, false otherwise\&. 
.RE
.PP

.PP
Definition at line \fB1760\fP of file \fBclass\&.util\&.php\fP\&.
.nf
1761     {
1762         global $bearsamppLang, $bearsamppWinbinder;
1763         $name     = $bin\->getName();
1764         $service  = $bin\->getService();
1765         $boxTitle = sprintf($bearsamppLang\->getValue(Lang::START_SERVICE_TITLE), $name);
1766 
1767         if (!$service\->start()) {
1768             $serviceError    = sprintf($bearsamppLang\->getValue(Lang::START_SERVICE_ERROR), $name);
1769             $serviceErrorLog = sprintf('Error while starting the %s service', $name);
1770             if (!empty($syntaxCheckCmd)) {
1771                 $cmdSyntaxCheck = $bin\->getCmdLineOutput($syntaxCheckCmd);
1772                 if (!$cmdSyntaxCheck['syntaxOk']) {
1773                     $serviceError    \&.= PHP_EOL \&. sprintf($bearsamppLang\->getValue(Lang::STARTUP_SERVICE_SYNTAX_ERROR), $cmdSyntaxCheck['content']);
1774                     $serviceErrorLog \&.= sprintf(' (conf errors detected : %s)', $cmdSyntaxCheck['content']);
1775                 }
1776             }
1777             self::logError($serviceErrorLog);
1778             if ($showWindow) {
1779                 $bearsamppWinbinder\->messageBoxError($serviceError, $boxTitle);
1780             }
1781 
1782             return false;
1783         }
1784 
1785         return true;
1786     }
.PP
.fi

.PP
References \fB$bearsamppLang\fP, \fBlogError()\fP, \fBLang\\START_SERVICE_ERROR\fP, \fBLang\\START_SERVICE_TITLE\fP, and \fBLang\\STARTUP_SERVICE_SYNTAX_ERROR\fP\&.
.PP
Referenced by \fBBinPhp\\setEnable()\fP, and \fBActionService\\start()\fP\&.
.SS "startWith ( $string,  $search)\fR [static]\fP"
Checks if a string starts with a specified substring\&.

.PP
\fBParameters\fP
.RS 4
\fI$string\fP The string to check\&. 
.br
\fI$search\fP The substring to look for at the start of the string\&.
.RE
.PP
\fBReturns\fP
.RS 4
bool Returns true if the string starts with the search substring, otherwise false\&. 
.RE
.PP

.PP
Definition at line \fB154\fP of file \fBclass\&.util\&.php\fP\&.
.nf
155     {
156         // Return false if string is NULL or empty
157         if ($string === null || $string === '') {
158             return false;
159         }
160 
161         $length = strlen($search);
162 
163         return (substr($string, 0, $length) === $search);
164     }
.PP
.fi

.PP
Referenced by \fBBinApache\\checkPort()\fP, \fBBinMariadb\\checkPort()\fP, \fBBinMysql\\checkPort()\fP, \fBBinApache\\getModulesFromConf()\fP, \fBBinApache\\getModulesFromFolder()\fP, \fBBinApache\\getOfflineContent()\fP, \fBBinApache\\getOnlineContent()\fP, \fBBatch\\getOsInfo()\fP, \fBBatch\\getPearVersion()\fP, \fBBatch\\getProcessUsingPort()\fP, \fBRegistry\\getValue()\fP, \fBBinApache\\getVhostsUrl()\fP, \fBWin32Ps\\killBins()\fP, \fBAutoloader\\load()\fP, and \fBRegistry\\setValue()\fP\&.
.SS "stopLoading ()\fR [static]\fP"
Stops a previously started loading process and cleans up related resources\&. 
.PP
Definition at line \fB944\fP of file \fBclass\&.util\&.php\fP\&.
.nf
945     {
946         global $bearsamppCore;
947         if (file_exists($bearsamppCore\->getLoadingPid())) {
948             $pids = file($bearsamppCore\->getLoadingPid());
949             foreach ($pids as $pid) {
950                 Win32Ps::kill($pid);
951             }
952             @unlink($bearsamppCore\->getLoadingPid());
953         }
954     }
.PP
.fi

.PP
References \fB$bearsamppCore\fP, and \fBWin32Ps\\kill()\fP\&.
.PP
Referenced by \fBActionManualRestart\\__construct()\fP, \fBActionService\\__construct()\fP, \fBActionCheckVersion\\showVersionOkMessageBox()\fP, and \fBActionCheckVersion\\showVersionUpdateWindow()\fP\&.
.SS "utf8ToCp1252 ( $data)\fR [static]\fP"
Converts UTF-8 encoded data to Windows-1252 encoding\&.

.PP
\fBParameters\fP
.RS 4
\fI$data\fP The UTF-8 encoded data\&.
.RE
.PP
\fBReturns\fP
.RS 4
string Returns the data encoded in Windows-1252\&. 
.RE
.PP

.PP
Definition at line \fB915\fP of file \fBclass\&.util\&.php\fP\&.
.nf
916     {
917         return iconv('UTF\-8', 'WINDOWS\-1252//IGNORE', $data);
918     }
.PP
.fi

.PP
Referenced by \fBActionReload\\__construct()\fP\&.
.SH "Field Documentation"
.PP 
.SS "const LOG_DEBUG = 'DEBUG'"

.PP
Definition at line \fB42\fP of file \fBclass\&.util\&.php\fP\&.
.SS "const LOG_ERROR = 'ERROR'"
This code snippet defines constants for logging levels\&. 
.PP
Definition at line \fB39\fP of file \fBclass\&.util\&.php\fP\&.
.SS "const LOG_INFO = 'INFO'"

.PP
Definition at line \fB41\fP of file \fBclass\&.util\&.php\fP\&.
.SS "const LOG_TRACE = 'TRACE'"

.PP
Definition at line \fB43\fP of file \fBclass\&.util\&.php\fP\&.
.SS "const LOG_WARNING = 'WARNING'"

.PP
Definition at line \fB40\fP of file \fBclass\&.util\&.php\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Bearsampp from the source code\&.
