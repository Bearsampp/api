.TH "ActionLoading" 3 "Version 2025.8.29" "Bearsampp" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ActionLoading
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB__construct\fP ($args)"
.br
.ti -1c
.RI "\fBincrProgressBar\fP ($nb=1)"
.br
.ti -1c
.RI "\fBprocessLoading\fP ($window, $id, $ctrl, $param1, $param2)"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "const \fBGAUGE\fP = 20"
.br
.ti -1c
.RI "const \fBWINDOW_HEIGHT\fP = 90"
.br
.ti -1c
.RI "const \fBWINDOW_WIDTH\fP = 360"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBcheckAllServicesStarted\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fB$wbProgressBar\fP"
.br
.ti -1c
.RI "\fB$wbWindow\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Class \fBActionLoading\fP

.PP
This class handles the loading action, including the creation and management of a progress bar window\&. 
.PP
Definition at line \fB16\fP of file \fBclass\&.action\&.loading\&.php\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "__construct ( $args)"
\fBActionLoading\fP constructor\&.

.PP
Initializes the loading action, creates the progress bar window, and starts the main loop\&.

.PP
\fBParameters\fP
.RS 4
\fI$args\fP The arguments passed to the constructor\&. 
.RE
.PP

.PP
Definition at line \fB40\fP of file \fBclass\&.action\&.loading\&.php\fP\&.
.nf
41     {
42         global $bearsamppCore, $bearsamppLang, $bearsamppWinbinder;
43 
44         $bearsamppWinbinder\->reset();
45         $bearsamppCore\->addLoadingPid(Win32Ps::getCurrentPid());
46 
47         // Screen information
48         $screenArea = explode(' ', $bearsamppWinbinder\->getSystemInfo(WinBinder::SYSINFO_WORKAREA));
49         $screenWidth = intval($screenArea[2]);
50         $screenHeight = intval($screenArea[3]);
51         $xPos = $screenWidth \- self::WINDOW_WIDTH;
52         $yPos = $screenHeight \- self::WINDOW_HEIGHT \- 5;
53 
54         // Create the window and progress bar
55         $this\->wbWindow = $bearsamppWinbinder\->createWindow(null, ToolDialog, null, $xPos, $yPos, self::WINDOW_WIDTH, self::WINDOW_HEIGHT, WBC_TOP, null);
56         $bearsamppWinbinder\->createLabel($this\->wbWindow, $bearsamppLang\->getValue(Lang::LOADING), 42, 2, 295, null, WBC_LEFT);
57         $this\->wbProgressBar = $bearsamppWinbinder\->createProgressBar($this\->wbWindow, self::GAUGE, 42, 20, 290, 15);
58 
59         // Set the handler and start the main loop
60         $bearsamppWinbinder\->setHandler($this\->wbWindow, $this, 'processLoading', 10);
61         $bearsamppWinbinder\->mainLoop();
62     }
.PP
.fi

.PP
References \fB$bearsamppCore\fP, \fB$bearsamppLang\fP, \fBWin32Ps\\getCurrentPid()\fP, \fBLang\\LOADING\fP, and \fBWinBinder\\SYSINFO_WORKAREA\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "checkAllServicesStarted ()\fR [private]\fP"
Checks if all services have started successfully

.PP
\fBReturns\fP
.RS 4
bool True if all services are running, false otherwise 
.RE
.PP

.PP
Definition at line \fB152\fP of file \fBclass\&.action\&.loading\&.php\fP\&.
.nf
153     {
154         global $bearsamppBins, $bearsamppCore, $bearsamppRoot;
155         
156         Util::logTrace('Checking if all services have started successfully');
157         
158         $allStarted = true;
159         foreach ($bearsamppBins\->getServices() as $sName => $service) {
160             // Skip if service is not enabled
161             if (!$service\->isEnable()) {
162                 Util::logTrace('Service ' \&. $sName \&. ' is disabled, skipping check');
163                 continue;
164             }
165             
166             // Add timeout for service status check
167             $checkStartTime = microtime(true);
168             $checkTimeout = 5; // 5 seconds timeout
169             $serviceRunning = false;
170             
171             try {
172                 // Use a non\-blocking check with timeout
173                 $tempFile = $bearsamppCore\->getTmpPath() \&. '/service_check_' \&. uniqid() \&. '\&.tmp';
174                 
175                 // Start a background process to check the service
176                 $checkCmd = 'php \-r "' \&.
177                     'require \\'' \&. $bearsamppRoot\->getLibsPath() \&. '/classes/class\&.win32service\&.php\\'; ' \&.
178                     '$service = new Win32Service(\\'' \&. $service\->getName() \&. '\\'); ' \&.
179                     '$status = $service\->status(); ' \&.
180                     'file_put_contents(\\'' \&. $tempFile \&. '\\', $status == Win32Service::STATE_RUNNING ? \\'1\\' : \\'0\\'); ' \&.
181                     'exit(0);" > nul 2>&1';
182                 
183                 // Execute the command in background
184                 pclose(popen('start /B ' \&. $checkCmd, 'r'));
185                 
186                 // Wait for the result with timeout
187                 $startWait = microtime(true);
188                 while (!file_exists($tempFile) && (microtime(true) \- $startWait < $checkTimeout)) {
189                     usleep(100000); // 100ms
190                 }
191                 
192                 // Check if we got a result
193                 if (file_exists($tempFile)) {
194                     $result = file_get_contents($tempFile);
195                     $serviceRunning = ($result === '1');
196                     unlink($tempFile);
197                     Util::logTrace('Service ' \&. $sName \&. ' status check: ' \&. ($serviceRunning ? 'running' : 'not running'));
198                 } else {
199                     Util::logTrace('Service ' \&. $sName \&. ' status check timed out');
200                     $serviceRunning = false;
201                 }
202             } catch (\\Exception $e) {
203                 Util::logTrace('Exception during service status check for ' \&. $sName \&. ': ' \&. $e\->getMessage());
204                 $serviceRunning = false;
205             }
206             
207             if (!$serviceRunning) {
208                 Util::logTrace('Service ' \&. $sName \&. ' is not running');
209                 $allStarted = false;
210                 break;
211             }
212         }
213         
214         Util::logTrace('All services started check result: ' \&. ($allStarted ? 'true' : 'false'));
215         return $allStarted;
216     }
.PP
.fi

.PP
References \fB$bearsamppBins\fP, \fB$bearsamppCore\fP, \fB$bearsamppRoot\fP, \fB$result\fP, and \fBUtil\\logTrace()\fP\&.
.PP
Referenced by \fBprocessLoading()\fP\&.
.SS "incrProgressBar ( $nb = \fR1\fP)"
Increments the progress bar by a specified number of steps\&.

.PP
\fBParameters\fP
.RS 4
\fI$nb\fP The number of steps to increment the progress bar by\&. Default is 1\&. 
.RE
.PP

.PP
Definition at line \fB69\fP of file \fBclass\&.action\&.loading\&.php\fP\&.
.nf
70     {
71         global $bearsamppCore, $bearsamppWinbinder;
72 
73         for ($i = 0; $i < $nb; $i++) {
74             $bearsamppWinbinder\->incrProgressBar($this\->wbProgressBar);
75             $bearsamppWinbinder\->drawImage($this\->wbWindow, $bearsamppCore\->getImagesPath() \&. '/bearsampp\&.bmp', 4, 2, 32, 32);
76         }
77 
78         $bearsamppWinbinder\->wait();
79         $bearsamppWinbinder\->wait($this\->wbWindow);
80     }
.PP
.fi

.PP
References \fB$bearsamppCore\fP\&.
.PP
Referenced by \fBprocessLoading()\fP\&.
.SS "processLoading ( $window,  $id,  $ctrl,  $param1,  $param2)"
Processes the loading action, including handling window events and updating the progress bar\&.

.PP
\fBParameters\fP
.RS 4
\fI$window\fP The window object\&. 
.br
\fI$id\fP The ID of the event\&. 
.br
\fI$ctrl\fP The control object\&. 
.br
\fI$param1\fP The first parameter of the event\&. 
.br
\fI$param2\fP The second parameter of the event\&. 
.RE
.PP

.PP
Definition at line \fB91\fP of file \fBclass\&.action\&.loading\&.php\fP\&.
.nf
92     {
93         global $bearsamppRoot, $bearsamppWinbinder;
94 
95         switch ($id) {
96             case IDCLOSE:
97                 Win32Ps::kill(Win32Ps::getCurrentPid());
98                 break;
99         }
100 
101         // Set a maximum number of iterations to prevent infinite loops
102         $maxIterations = 10;
103         $iterations = 0;
104 
105         // Set a timeout for the entire loading process
106         $startTime = microtime(true); // Use microtime for more precise timing
107         $maxLoadingTime = 15; // 15 seconds maximum
108 
109         while ($iterations < $maxIterations && (microtime(true) \- $startTime) < $maxLoadingTime) {
110             $bearsamppRoot\->removeErrorHandling();
111             $bearsamppWinbinder\->resetProgressBar($this\->wbProgressBar);
112 
113             usleep(100000);
114 
115             for ($i = 0; $i < self::GAUGE && (microtime(true) \- $startTime) < $maxLoadingTime; $i++) {
116                 $this\->incrProgressBar();
117                 usleep(100000);
118             }
119 
120             // Check if all services have started successfully
121             $allServicesStarted = $this\->checkAllServicesStarted();
122             if ($allServicesStarted) {
123                 Util::logTrace('All services started successfully');
124                 break;
125             }
126 
127             $iterations++;
128             Util::logTrace('Loading iteration ' \&. $iterations \&. ' completed, checking services again');
129         }
130 
131         if ($iterations >= $maxIterations) {
132             Util::logTrace('Maximum iterations reached (' \&. $maxIterations \&. '), some services may not have started properly');
133         }
134         
135         if ((microtime(true) \- $startTime) >= $maxLoadingTime) {
136             Util::logTrace('Loading timeout reached (' \&. $maxLoadingTime \&. ' seconds), some services may not have started properly');
137         }
138         
139         // Add a small delay before killing the process to ensure UI updates are complete
140         usleep(500000); // 500ms
141         
142         // Close the loading window
143         Util::logTrace('Closing loading window');
144         Win32Ps::kill(Win32Ps::getCurrentPid());
145     }
.PP
.fi

.PP
References \fB$bearsamppRoot\fP, \fBcheckAllServicesStarted()\fP, \fBWin32Ps\\getCurrentPid()\fP, \fBincrProgressBar()\fP, \fBWin32Ps\\kill()\fP, and \fBUtil\\logTrace()\fP\&.
.SH "Field Documentation"
.PP 
.SS "$wbProgressBar\fR [private]\fP"

.PP
Definition at line \fB31\fP of file \fBclass\&.action\&.loading\&.php\fP\&.
.SS "$wbWindow\fR [private]\fP"

.PP
Definition at line \fB28\fP of file \fBclass\&.action\&.loading\&.php\fP\&.
.SS "const GAUGE = 20"

.PP
Definition at line \fB25\fP of file \fBclass\&.action\&.loading\&.php\fP\&.
.SS "const WINDOW_HEIGHT = 90"

.PP
Definition at line \fB22\fP of file \fBclass\&.action\&.loading\&.php\fP\&.
.SS "const WINDOW_WIDTH = 360"

.PP
Definition at line \fB19\fP of file \fBclass\&.action\&.loading\&.php\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Bearsampp from the source code\&.
