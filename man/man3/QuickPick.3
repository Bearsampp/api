.TH "QuickPick" 3 "Version 2025.8.29" "Bearsampp" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QuickPick
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB__construct\fP ()"
.br
.ti -1c
.RI "\fBcheckDownloadId\fP ()"
.br
.ti -1c
.RI "\fBcheckQuickpickJson\fP ()"
.br
.ti -1c
.RI "\fBfetchAndUnzipModule\fP (string $moduleUrl, string $module)"
.br
.ti -1c
.RI "\fBgetModuleDestinationPath\fP (string $moduleType, string $moduleName)"
.br
.ti -1c
.RI "\fBgetModules\fP ()"
.br
.ti -1c
.RI "\fBgetModuleUrl\fP (string $module, string $version)"
.br
.ti -1c
.RI "\fBgetQuickpickJson\fP ()"
.br
.ti -1c
.RI "\fBgetQuickpickMenu\fP (array $modules, array $versions, string $imagesPath)"
.br
.ti -1c
.RI "\fBgetVersions\fP ()"
.br
.ti -1c
.RI "\fBinstallModule\fP (string $module, string $version)"
.br
.ti -1c
.RI "\fBloadQuickpick\fP (string $imagesPath)"
.br
.ti -1c
.RI "\fBrebuildQuickpickJson\fP ()"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fB$modules\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBformatVersionLabel\fP ($version, $isPrerelease=false)"
.br
.ti -1c
.RI "\fBgetLocalFileCreationTime\fP ()"
.br
.ti -1c
.RI "\fBisValidHeaderResponse\fP ($headers)"
.br
.ti -1c
.RI "\fBlogHeaders\fP (array $headers)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fB$jsonFilePath\fP"
.br
.ti -1c
.RI "\fB$versions\fP = []"
.br
.in -1c
.SH "Detailed Description"
.PP 
Class \fBQuickPick\fP

.PP
The \fBQuickPick\fP class provides functionalities for managing and installing various modules within the \fBBearsampp\fP application\&. It includes methods for retrieving available modules, fetching module versions, parsing release properties, and validating license keys\&. 
.PP
Definition at line \fB18\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "__construct ()"
Constructor to initialize the jsonFilePath\&. 
.PP
Definition at line \fB69\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
70     {
71         global $bearsamppCore;
72         $this\->jsonFilePath = $bearsamppCore\->getResourcesPath() \&. '/quickpick\-releases\&.json';
73     }
.PP
.fi

.PP
References \fB$bearsamppCore\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "checkDownloadId ()"
Validates the format of a given username key by checking it against an external API\&.

.PP
This method performs several checks to ensure the validity of the username key:
.IP "1." 4
Logs the method call\&.
.IP "2." 4
Ensures the global configuration is available\&.
.IP "3." 4
Retrieves the username key from the global configuration\&.
.IP "4." 4
Ensures the username key is not empty\&.
.IP "5." 4
Constructs the API URL using the username key\&.
.IP "6." 4
Fetches the API response\&.
.IP "7." 4
Decodes the JSON response\&.
.IP "8." 4
Validates the response data\&.
.PP

.PP
\fBReturns\fP
.RS 4
bool True if the username key is valid, false otherwise\&. 
.RE
.PP

.PP
Definition at line \fB341\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
341                                      : bool
342     {
343         global $bearsamppConfig;
344 
345         Util::logDebug( 'checkDownloadId method called\&.' );
346 
347         // Ensure the global config is available
348         if ( !isset( $bearsamppConfig ) ) {
349             Util::logError( 'Global configuration is not set\&.' );
350 
351             return false;
352         }
353 
354         $DownloadId = $bearsamppConfig\->getDownloadId();
355         Util::logDebug( 'DownloadId is: ' \&. $DownloadId );
356 
357         // Ensure the license key is not empty
358         if ( empty( $DownloadId ) ) {
359             Util::logError( 'License key is empty\&.' );
360 
361             return false;
362         }
363 
364         $url = QUICKPICK_API_URL \&. QUICKPICK_API_KEY \&. '&download_id=' \&. $DownloadId;
365         Util::logDebug( 'API URL: ' \&. $url );
366 
367         $response = @file_get_contents( $url );
368 
369         // Check if the response is false
370         if ( $response === false ) {
371             $error = error_get_last();
372             Util::logError( 'Error fetching API response: ' \&. $error['message'] );
373 
374             return false;
375         }
376 
377         Util::logDebug( 'API response: ' \&. $response );
378 
379         $data = json_decode( $response, true );
380 
381         // Check if the JSON decoding was successful
382         if ( json_last_error() !== JSON_ERROR_NONE ) {
383             Util::logError( 'Error decoding JSON response: ' \&. json_last_error_msg() );
384 
385             return false;
386         }
387 
388         // Validate the response data
389         if ( isset( $data['success'] ) && $data['success'] === true && isset( $data['data'] ) && is_array( $data['data'] ) && count( $data['data'] ) > 0 ) {
390             Util::logDebug( 'License key valid: ' \&. $DownloadId );
391 
392             return true;
393         }
394 
395         Util::logError( 'Invalid license key: ' \&. $DownloadId );
396 
397         return false;
398     }
.PP
.fi

.PP
References \fB$bearsamppConfig\fP, \fB$response\fP, \fBUtil\\logDebug()\fP, \fBUtil\\logError()\fP, \fBQUICKPICK_API_KEY\fP, and \fBQUICKPICK_API_URL\fP\&.
.PP
Referenced by \fBgetQuickpickMenu()\fP\&.
.SS "checkQuickpickJson ()"
Checks if the local \fRquickpick-releases\&.json\fP file is up-to-date with the remote version\&.

.PP
Compares the creation time of the local JSON file with the remote file's last modified time\&. If the remote file is newer or the local file does not exist, it fetches the latest JSON data by calling the \fRrebuildQuickpickJson\fP method\&.

.PP
\fBReturns\fP
.RS 4
array|false Returns the JSON data if the remote file is newer or the local file does not exist, otherwise returns false\&. 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIException\fP 
.RE
.PP

.PP
Definition at line \fB133\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
134     {
135         global $bearsamppConfig;
136 
137         // Determine local file creation time or rebuild if missing
138         $localFileCreationTime = $this\->getLocalFileCreationTime();
139 
140         // Attempt to retrieve remote file headers
141         $headers = get_headers(QUICKPICK_JSON_URL, 1);
142         if (!$this\->isValidHeaderResponse($headers)) {
143             // If headers or Date are invalid, assume no update needed
144             return false;
145         }
146 
147         // Optionally log headers for verbose output
148         $this\->logHeaders($headers);
149 
150         // Compare the creation times (remote vs\&. local)
151         $remoteFileCreationTime = strtotime(isset($headers['Date']) ? $headers['Date'] : '');
152         if ($remoteFileCreationTime > $localFileCreationTime) { return $this\->rebuildQuickpickJson(); }
153 
154         // Return false if local file is already up\-to\-date
155         return false;
156     }
.PP
.fi

.PP
References \fB$bearsamppConfig\fP, \fBgetLocalFileCreationTime()\fP, \fBisValidHeaderResponse()\fP, \fBlogHeaders()\fP, \fBQUICKPICK_JSON_URL\fP, and \fBrebuildQuickpickJson()\fP\&.
.PP
Referenced by \fBloadQuickpick()\fP\&.
.SS "fetchAndUnzipModule (string $moduleUrl, string $module)"
Fetches the module URL and stores it in /tmp, then unzips the file based on its extension\&.

.PP
\fBParameters\fP
.RS 4
\fI$moduleUrl\fP The URL of the module to fetch\&. 
.br
\fI$module\fP The name of the module\&.
.RE
.PP
\fBReturns\fP
.RS 4
array An array containing the status and message\&. 
.RE
.PP

.PP
Definition at line \fB453\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
453                                                                           : array
454 {
455     Util::logDebug("$module is: " \&. $module);
456 
457     global $bearsamppRoot, $bearsamppCore;
458     $tmpDir = $bearsamppRoot\->getTmpPath();
459     Util::logDebug('Temporary Directory: ' \&. $tmpDir);
460 
461     $fileName = basename($moduleUrl);
462     Util::logDebug('File Name: ' \&. $fileName);
463 
464     $tmpFilePath = $tmpDir \&. '/' \&. $fileName;
465     Util::logDebug('File Path: ' \&. $tmpFilePath);
466 
467     $moduleName = str_replace('module\-', '', $module);
468     Util::logDebug('Module Name: ' \&. $moduleName);
469 
470     $moduleType = $this\->modules[$module]['type'];
471     Util::logDebug('Module Type: ' \&. $moduleType);
472 
473     // Get module type
474     $destination = $this\->getModuleDestinationPath($moduleType, $moduleName);
475     Util::logDebug('Destination: ' \&. $destination);
476 
477     // Retrieve the file path from the URL using the bearsamppCore module,
478     // passing the module URL and temporary file path, with the use Progress Bar parameter set to true\&.
479     $result = $bearsamppCore\->getFileFromUrl($moduleUrl, $tmpFilePath, true);
480 
481     // Check if $result is false
482     if ($result === false) {
483         Util::logError('Failed to retrieve file from URL: ' \&. $moduleUrl);
484         return ['error' => 'Failed to retrieve file from URL'];
485     }
486 
487     // Determine the file extension and call the appropriate unzipping function
488     $fileExtension = pathinfo($tmpFilePath, PATHINFO_EXTENSION);
489     Util::logDebug('File extension: ' \&. $fileExtension);
490 
491     if ($fileExtension === '7z' || $fileExtension === 'zip') {
492         // Send phase indicator for extraction
493         echo json_encode(['phase' => 'extracting']);
494         if (ob_get_length()) {
495             ob_flush();
496         }
497         flush();
498 
499         $unzipResult = $bearsamppCore\->unzipFile($tmpFilePath, $destination, function ($currentPercentage) {
500             echo json_encode(['progress' => "$currentPercentage%"]);
501             if (ob_get_length()) {
502                 ob_flush();
503             }
504             flush();
505         });
506 
507         if ($unzipResult === false) {
508             return ['error' => 'Failed to unzip file\&. File: ' \&. $tmpFilePath \&. ' could not be unzipped', 'Destination: ' \&. $destination];
509         }
510     } else {
511         Util::logError('Unsupported file extension: ' \&. $fileExtension);
512         return ['error' => 'Unsupported file extension'];
513     }
514 
515     return ['success' => 'Module installed successfully'];
516 }
.PP
.fi

.PP
References \fB$bearsamppCore\fP, \fB$bearsamppRoot\fP, \fB$result\fP, \fBgetModuleDestinationPath()\fP, \fBUtil\\logDebug()\fP, and \fBUtil\\logError()\fP\&.
.PP
Referenced by \fBinstallModule()\fP\&.
.SS "formatVersionLabel ( $version,  $isPrerelease = \fRfalse\fP)\fR [private]\fP"
Format version label with PR indicator if it's a prerelease

.PP
\fBParameters\fP
.RS 4
\fI$version\fP The version to format 
.br
\fI$isPrerelease\fP Whether this version is a prerelease 
.RE
.PP
\fBReturns\fP
.RS 4
string Formatted version string 
.RE
.PP

.PP
Definition at line \fB82\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
82                                                                          {
83         global $bearsamppConfig;
84         $includePr = $bearsamppConfig\->getIncludePr();
85 
86         if ($isPrerelease && $includePr == 1) {
87             return '<span class="text\-danger">' \&. htmlspecialchars($version) \&. ' PR</span>';
88         }
89 
90         return htmlspecialchars($version);
91     }
.PP
.fi

.PP
References \fB$bearsamppConfig\fP\&.
.SS "getLocalFileCreationTime ()\fR [private]\fP"
Returns the local file's creation time, or triggers and returns 0 if file does not exist\&.

.PP
\fBReturns\fP
.RS 4
int Local file's creation time or 0 if the file doesn't exist\&. 
.RE
.PP

.PP
Definition at line \fB163\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
164     {
165         if (!file_exists($this\->jsonFilePath)) {
166             // If local file is missing, rebuild it immediately
167             $this\->rebuildQuickpickJson();
168             return 0;
169         }
170         return filectime($this\->jsonFilePath);
171     }
.PP
.fi

.PP
References \fBrebuildQuickpickJson()\fP\&.
.PP
Referenced by \fBcheckQuickpickJson()\fP\&.
.SS "getModuleDestinationPath (string $moduleType, string $moduleName)"
Get the destination path for a given module type and name\&.

.PP
This method constructs the destination path based on the type of module (application, binary, or tools) and the module name\&. It utilizes the \fRbearsamppRoot\fP global object to retrieve the base paths for each module type\&.

.PP
\fBParameters\fP
.RS 4
\fI$moduleType\fP The type of the module ('application', 'binary', or 'tools')\&. 
.br
\fI$moduleName\fP The name of the module\&.
.RE
.PP
\fBReturns\fP
.RS 4
string The constructed destination path for the module\&. 
.RE
.PP

.PP
Definition at line \fB530\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
531     {
532         global $bearsamppRoot;
533         if ( $moduleType === 'application' ) {
534             $destination = $bearsamppRoot\->getAppsPath() \&. '/' \&. strtolower( $moduleName ) \&. '/';
535         }
536         elseif ( $moduleType === 'binary' ) {
537             $destination = $bearsamppRoot\->getBinPath() \&. '/' \&. strtolower( $moduleName ) \&. '/';
538         }
539         elseif ( $moduleType === 'tools' ) {
540             $destination = $bearsamppRoot\->getToolsPath() \&. '/' \&. strtolower( $moduleName ) \&. '/';
541         }
542         else {
543             $destination = '';
544         }
545 
546         return $destination;
547     }
.PP
.fi

.PP
References \fB$bearsamppRoot\fP\&.
.PP
Referenced by \fBfetchAndUnzipModule()\fP\&.
.SS "getModules ()"
Retrieves the list of available modules\&.

.PP
\fBReturns\fP
.RS 4
array An array of module names\&. 
.RE
.PP

.PP
Definition at line \fB98\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
98                                 : array
99     {
100         return array_keys( $this\->modules );
101     }
.PP
.fi

.PP
Referenced by \fBloadQuickpick()\fP\&.
.SS "getModuleUrl (string $module, string $version)"
Fetches the URL of a specified module version from the local quickpick-releases\&.json file\&.

.PP
This method reads the quickpick-releases\&.json file to find the URL associated with the given module and version\&. It logs the process and returns the URL if found, or an error message if not\&.

.PP
\fBParameters\fP
.RS 4
\fI$module\fP The name of the module\&. 
.br
\fI$version\fP The version of the module\&.
.RE
.PP
\fBReturns\fP
.RS 4
string|array The URL of the specified module version or an error message if the version is not found\&. 
.RE
.PP

.PP
Definition at line \fB309\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
310     {
311         $this\->getVersions();
312         Util::logDebug( 'getModuleUrl called for module: ' \&. $module \&. ' version: ' \&. $version );
313         $url = trim( $this\->versions['module\-' \&. strtolower( $module )][$version]['url'] );
314         if ( $url <> '' ) {
315             Util::logDebug( 'Found URL for version: ' \&. $version \&. ' URL: ' \&. $url );
316 
317             return $url;
318         }
319         else {
320             Util::logError( 'Version not found: ' \&. $version );
321 
322             return ['error' => 'Version not found'];
323         }
324     }
.PP
.fi

.PP
References \fBgetVersions()\fP, \fBUtil\\logDebug()\fP, and \fBUtil\\logError()\fP\&.
.PP
Referenced by \fBinstallModule()\fP\&.
.SS "getQuickpickJson ()"
Retrieves the \fBQuickPick\fP JSON data from the local file\&.

.PP
\fBReturns\fP
.RS 4
array The decoded JSON data, or an error message if the file cannot be fetched or decoded\&. 
.RE
.PP

.PP
Definition at line \fB207\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
207                                       : array
208     {
209         $content = @file_get_contents( $this\->jsonFilePath );
210         if ( $content === false ) {
211             Util::logError( 'Error fetching content from JSON file: ' \&. $this\->jsonFilePath );
212 
213             return ['error' => 'Error fetching JSON file'];
214         }
215 
216         $data = json_decode( $content, true );
217         if ( json_last_error() !== JSON_ERROR_NONE ) {
218             Util::logError( 'Error decoding JSON content: ' \&. json_last_error_msg() );
219 
220             return ['error' => 'Error decoding JSON content'];
221         }
222 
223         return $data;
224     }
.PP
.fi

.PP
References \fBUtil\\logError()\fP\&.
.PP
Referenced by \fBgetVersions()\fP\&.
.SS "getQuickpickMenu (array $modules, array $versions, string $imagesPath)"
Generates the HTML content for the \fBQuickPick\fP menu\&.

.PP
This method creates the HTML structure for the \fBQuickPick\fP interface, including a dropdown for selecting modules and their respective versions\&. It checks if the license key is valid before displaying the modules\&. If the license key is invalid, it displays a subscription prompt\&. If there is no internet connection, it displays a message indicating the lack of internet\&.

.PP
\fBParameters\fP
.RS 4
\fI$modules\fP An array of available modules\&. 
.br
\fI$versions\fP An associative array where the key is the module name and the value is an array containing the module versions\&. 
.br
\fI$imagesPath\fP The path to the images directory\&.
.RE
.PP
\fBReturns\fP
.RS 4
string The HTML content of the \fBQuickPick\fP menu\&. 
.RE
.PP

.PP
Definition at line \fB563\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
563                                                                                          : string
564     {
565         global $bearsamppConfig;
566         $includePr = $bearsamppConfig\->getIncludePr();
567         
568         ob_start();
569         if ( Util::checkInternetState() ) {
570 
571             // Check if the license key is valid
572             if ( $this\->checkDownloadId() ): ?>
573                 <div id = 'quickPickContainer'>
574                     <div class = 'quickpick me\-5'>
575 
576                         <div class = "custom\-select">
577                             <button class = "select\-button" role = "combobox"
578                                     aria\-label = "select button"
579                                     aria\-haspopup = "listbox"
580                                     aria\-expanded = "false"
581                                     aria\-controls = "select\-dropdown">
582                                 <span class = "selected\-value">Select a module and version</span>
583                                 <span class = "arrow"></span>
584                             </button>
585                             <ul class = "select\-dropdown" role = "listbox" id = "select\-dropdown">
586 
587                                 <?php
588                                 foreach ( $modules as $module ): ?>
589                                     <?php if ( is_string( $module ) ): ?>
590                                         <li role = "option" class = "moduleheader">
591                                             <?php echo htmlspecialchars( $module ); ?>
592                                         </li>
593 
594                                         <?php
595                                         foreach ( $versions['module\-' \&. strtolower( $module )] as $version_array ): 
596                                             // Skip prerelease versions if includePr is not enabled
597                                             if (isset($version_array['prerelease']) && $version_array['prerelease'] === true && $includePr != 1) {
598                                                 continue;
599                                             }
600                                         ?>
601                                             <li role = "option" class = "moduleoption"
602                                                 id = "<?php echo htmlspecialchars( $module ); ?>\-version\-<?php echo htmlspecialchars( $version_array['version'] ); ?>\-li">
603                                                 <input type = "radio"
604                                                        id = "<?php echo htmlspecialchars( $module ); ?>\-version\-<?php echo htmlspecialchars( $version_array['version'] ); ?>"
605                                                        name = "module" data\-module = "<?php echo htmlspecialchars( $module ); ?>"
606                                                        data\-value = "<?php echo htmlspecialchars( $version_array['version'] ); ?>">
607                                                 <label
608                                                     for = "<?php echo htmlspecialchars( $module ); ?>\-version\-<?php echo htmlspecialchars( $version_array['version'] ); ?>"><?php echo $this\->formatVersionLabel( $version_array['version'], isset($version_array['prerelease']) && $version_array['prerelease'] === true ); ?></label>
609                                             </li>
610                                         <?php endforeach; ?>
611                                     <?php endif; ?>
612                                 <?php endforeach; ?>
613                             </ul>
614                         </div>
615                     </div>
616                     <div class = "progress " id = "progress" tabindex = "\-1" style = "width:260px;display:none"
617                          aria\-labelledby = "progressbar" aria\-hidden = "true">
618                         <div class = "progress\-bar progress\-bar\-striped progress\-bar\-animated" id = "progress\-bar" role = "progressbar" aria\-valuenow = "0" aria\-valuemin = "0"
619                              aria\-valuemax = "100" data\-module = "Module"
620                              data\-version = "0\&.0\&.0">0%
621                         </div>
622                         <div id = "download\-module" style = "display: none">ModuleName</div>
623                         <div id = "download\-version" style = "display: none">Version</div>
624                     </div>
625                 </div>
626             <?php else: ?>
627                 <div id = "subscribeContainer" class = "text\-center mt\-3 pe\-3">
628                     <a href = "<?php echo Util::getWebsiteUrl( 'subscribe' ); ?>" class = "btn btn\-dark d\-inline\-flex align\-items\-center">
629                         <img src = "<?php echo $imagesPath \&. 'subscribe\&.svg'; ?>" alt = "Subscribe Icon" class = "me\-2">
630                         Subscribe to QuickPick now
631                     </a>
632                 </div>
633             <?php endif;
634         }
635         else {
636             ?>
637             <div id = "InternetState" class = "text\-center mt\-3 pe\-3">
638                 <img src = "<?php echo $imagesPath \&. 'no\-wifi\-icon\&.svg'; ?>" alt = "No Wifi Icon" class = "me\-2">
639                 <span>No internet present</span>
640             </div>
641             <?php
642         }
643 
644         return ob_get_clean();
645     }
.PP
.fi

.PP
References \fB$bearsamppConfig\fP, \fB$imagesPath\fP, \fB$modules\fP, \fB$versions\fP, \fBcheckDownloadId()\fP, \fBUtil\\checkInternetState()\fP, and \fBUtil\\getWebsiteUrl()\fP\&.
.PP
Referenced by \fBloadQuickpick()\fP\&.
.SS "getVersions ()"
Retrieves the list of available versions for all modules\&.

.PP
This method fetches the \fBQuickPick\fP JSON data and returns an array of versions or If no versions are found, an error message is logged and returned\&.

.PP
\fBReturns\fP
.RS 4
array An array of version strings for the specified module, or an error message if no versions are found\&. 
.RE
.PP

.PP
Definition at line \fB264\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
264                                  : array
265     {
266         Util::logDebug( 'Versions called' );
267 
268         $versions = [];
269 
270         $jsonData = $this\->getQuickpickJson();
271 
272         foreach ( $jsonData as $entry ) {
273             if ( is_array( $entry ) ) {
274                 if ( isset( $entry['module'] ) && is_string( $entry['module'] ) ) {
275                     if ( isset( $entry['versions'] ) && is_array( $entry['versions'] ) ) {
276                         $versions[$entry['module']] = array_column( $entry['versions'], null, 'version' );
277                     }
278                 }
279             }
280             else {
281                 Util::logError( 'Invalid entry format in JSON data' );
282             }
283         }
284 
285         if ( empty( $versions ) ) {
286             Util::logError( 'No versions found' );
287 
288             return ['error' => 'No versions found'];
289         }
290 
291         Util::logDebug( 'Found versions' );
292 
293         $this\->versions = $versions;
294 
295         return $versions;
296     }
.PP
.fi

.PP
References \fB$versions\fP, \fBgetQuickpickJson()\fP, \fBUtil\\logDebug()\fP, and \fBUtil\\logError()\fP\&.
.PP
Referenced by \fBgetModuleUrl()\fP, and \fBloadQuickpick()\fP\&.
.SS "installModule (string $module, string $version)"
Installs a specified module by fetching its URL and unzipping its contents\&.

.PP
This method retrieves the URL of the specified module and version from the \fBQuickPick\fP JSON data\&. If the URL is found, it fetches and unzips the module\&. If the URL is not found, it logs an error and returns an error message\&.

.PP
\fBParameters\fP
.RS 4
\fI$module\fP The name of the module to install\&. 
.br
\fI$version\fP The version of the module to install\&.
.RE
.PP
\fBReturns\fP
.RS 4
array An array containing the status and message of the installation process\&. If successful, it returns the response from the fetchAndUnzipModule method\&. If unsuccessful, it returns an error message indicating the issue\&. 
.RE
.PP

.PP
Definition at line \fB414\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
414                                                                   : array
415     {
416         // Find the module URL and module name from the data
417         $moduleUrl = $this\->getModuleUrl( $module, $version );
418 
419         if ( is_array( $moduleUrl ) && isset( $moduleUrl['error'] ) ) {
420             Util::logError( 'Module URL not found for module: ' \&. $module \&. ' version: ' \&. $version );
421 
422             return ['error' => 'Module URL not found'];
423         }
424 
425         if ( empty( $moduleUrl ) ) {
426             Util::logError( 'Module URL not found for module: ' \&. $module \&. ' version: ' \&. $version );
427 
428             return ['error' => 'Module URL not found'];
429         }
430 
431         $state = Util::checkInternetState();
432         if ( $state ) {
433             $response = $this\->fetchAndUnzipModule( $moduleUrl, $module );
434             Util::logDebug( 'Response is: ' \&. print_r( $response, true ) );
435 
436             return $response;
437         }
438         else {
439             Util::logError( 'No internet connection available\&.' );
440 
441             return ['error' => 'No internet connection'];
442         }
443     }
.PP
.fi

.PP
References \fB$response\fP, \fBUtil\\checkInternetState()\fP, \fBfetchAndUnzipModule()\fP, \fBgetModuleUrl()\fP, \fBUtil\\logDebug()\fP, and \fBUtil\\logError()\fP\&.
.SS "isValidHeaderResponse ( $headers)\fR [private]\fP"
Determines whether the header response is valid and includes a 'Date' key\&.

.PP
\fBParameters\fP
.RS 4
\fI$headers\fP Headers retrieved from get_headers()\&. 
.RE
.PP
\fBReturns\fP
.RS 4
bool True if headers are valid and contain 'Date', false otherwise\&. 
.RE
.PP

.PP
Definition at line \fB179\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
179                                                     : bool
180     {
181         // If headers retrieval failed or Date is not set, return false
182         if ($headers === false || !isset($headers['Date'])) {
183             return false;
184         }
185         return true;
186     }
.PP
.fi

.PP
Referenced by \fBcheckQuickpickJson()\fP\&.
.SS "loadQuickpick (string $imagesPath)"
Loads the \fBQuickPick\fP interface with the available modules and their versions\&.

.PP
\fBParameters\fP
.RS 4
\fI$imagesPath\fP The path to the images directory\&.
.RE
.PP
\fBReturns\fP
.RS 4
string The HTML content of the \fBQuickPick\fP interface\&.
.RE
.PP
\fBExceptions\fP
.RS 4
\fIException\fP 
.RE
.PP

.PP
Definition at line \fB112\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
112                                                      : string
113     {
114         $this\->checkQuickpickJson();
115 
116         $modules  = $this\->getModules();
117         $versions = $this\->getVersions();
118 
119         return $this\->getQuickpickMenu( $modules, $versions, $imagesPath );
120     }
.PP
.fi

.PP
References \fB$imagesPath\fP, \fB$modules\fP, \fB$versions\fP, \fBcheckQuickpickJson()\fP, \fBgetModules()\fP, \fBgetQuickpickMenu()\fP, and \fBgetVersions()\fP\&.
.SS "logHeaders (array $headers)\fR [private]\fP"
Logs the headers in debug mode if logsVerbose is set to 2\&.

.PP
\fBParameters\fP
.RS 4
\fI$headers\fP The headers returned by get_headers()\&. 
.RE
.PP

.PP
Definition at line \fB193\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
193                                                : void
194     {
195         global $bearsamppConfig;
196 
197         if ($bearsamppConfig\->getLogsVerbose() === 2) {
198             Util::logDebug('Headers: ' \&. print_r($headers, true));
199         }
200     }
.PP
.fi

.PP
References \fB$bearsamppConfig\fP, and \fBUtil\\logDebug()\fP\&.
.PP
Referenced by \fBcheckQuickpickJson()\fP\&.
.SS "rebuildQuickpickJson ()"
Rebuilds the local quickpick-releases\&.json file by fetching the latest data from the remote URL\&.

.PP
\fBReturns\fP
.RS 4
array An array containing the status and message of the rebuild process\&. 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIException\fP If the JSON content cannot be fetched or saved\&. 
.RE
.PP

.PP
Definition at line \fB232\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.nf
232                                           : array
233     {
234         Util::logDebug( 'Fetching JSON file: ' \&. $this\->jsonFilePath );
235 
236         // Fetch the JSON content from the URL
237         $jsonContent = file_get_contents( QUICKPICK_JSON_URL );
238 
239         if ( $jsonContent === false ) {
240             // Handle error if the file could not be fetched
241             throw new Exception( 'Failed to fetch JSON content from the URL\&.' );
242         }
243 
244         // Save the JSON content to the specified path
245         $result = file_put_contents( $this\->jsonFilePath, $jsonContent );
246 
247         if ( $result === false ) {
248             // Handle error if the file could not be saved
249             throw new Exception( 'Failed to save JSON content to the specified path\&.' );
250         }
251 
252         // Return success message
253         return ['success' => 'JSON content fetched and saved successfully'];
254     }
.PP
.fi

.PP
References \fB$result\fP, \fBUtil\\logDebug()\fP, and \fBQUICKPICK_JSON_URL\fP\&.
.PP
Referenced by \fBcheckQuickpickJson()\fP, and \fBgetLocalFileCreationTime()\fP\&.
.SH "Field Documentation"
.PP 
.SS "$jsonFilePath\fR [private]\fP"
The file path to the local quickpick-releases\&.json file\&. 
.PP
Definition at line \fB64\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.SS "$modules"
\fBInitial value:\fP
.nf
= [
        'Apache'      => ['type' => 'binary'],
        'Bruno'       => ['type' => 'tools'],
        'Composer'    => ['type' => 'tools'],
        'ConsoleZ'    => ['type' => 'tools'],
        'Ghostscript' => ['type' => 'tools'],
        'Git'         => ['type' => 'tools'],
        'Mailpit'     => ['type' => 'binary'],
        'MariaDB'     => ['type' => 'binary'],
        'Memcached'   => ['type' => 'binary'],
        'MySQL'       => ['type' => 'binary'],
        'Ngrok'       => ['type' => 'tools'],
        'NodeJS'      => ['type' => 'binary'],
        'Perl'        => ['type' => 'tools'],
        'PHP'         => ['type' => 'binary'],
        'PhpMyAdmin'  => ['type' => 'application'],
        'PhpPgAdmin'  => ['type' => 'application'],
        'PostgreSQL'  => ['type' => 'binary'],
        'Python'      => ['type' => 'tools'],
        'Ruby'        => ['type' => 'tools'],
        'Xlight'      => ['type' => 'binary']
    ]
.PP
.fi
An associative array where the key is the module name and the value is an array containing the module type\&. The module type can be one of the following:
.IP "\(bu" 2
'application'
.IP "\(bu" 2
'binary'
.IP "\(bu" 2
'tool' 
.PP

.PP
Definition at line \fB29\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.PP
Referenced by \fBgetQuickpickMenu()\fP, and \fBloadQuickpick()\fP\&.
.SS "$versions = []\fR [private]\fP"
An associative array where the key is the module name and the value is an array containing the module versions\&. 
.PP
Definition at line \fB57\fP of file \fBclass\&.action\&.quickPick\&.php\fP\&.
.PP
Referenced by \fBgetQuickpickMenu()\fP, \fBgetVersions()\fP, and \fBloadQuickpick()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Bearsampp from the source code\&.
