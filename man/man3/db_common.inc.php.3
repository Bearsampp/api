.TH "E:/Bearsampp-development/sandbox/core/libs/winbinder/db/db_common.inc.php" 3 "Version 2025.8.29" "Bearsampp" \" -*- nroff -*-
.ad l
.nh
.SH NAME
E:/Bearsampp-development/sandbox/core/libs/winbinder/db/db_common.inc.php
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBdb_close_database\fP ()"
.br
.ti -1c
.RI "\fBdb_create_database\fP ($database, $server='', $username='', $password='')"
.br
.ti -1c
.RI "\fBdb_create_field\fP ($tablename, $field, $type)"
.br
.ti -1c
.RI "\fBdb_create_record\fP ($tablename, $fieldnames=null, $fieldvalues=null, $idfield='id')"
.br
.ti -1c
.RI "\fBdb_create_table\fP ($tablename, $fieldnames, $fieldattrib, $idfield='id', $valarray=null)"
.br
.ti -1c
.RI "\fBdb_delete_field\fP ($tablename, $field)"
.br
.ti -1c
.RI "\fBdb_delete_records\fP ($tablename, $idarray, $idfield='id')"
.br
.ti -1c
.RI "\fBdb_delete_table\fP ($tablename)"
.br
.ti -1c
.RI "\fBdb_edit_field\fP ($tablename, $field, $type)"
.br
.ti -1c
.RI "\fBdb_edit_record\fP ($tablename, $id=0, $fieldnames=null, $fieldvalues=null, $idfield='id')"
.br
.ti -1c
.RI "\fBdb_escape_string\fP ($str)"
.br
.ti -1c
.RI "\fBdb_fetch_array\fP ($result, $type=\fBFETCH_NUM\fP)"
.br
.ti -1c
.RI "\fBdb_free_result\fP ($result)"
.br
.ti -1c
.RI "\fBdb_get_data\fP ($tablename, $id=null, $col=null, $where='', $result_type=\fBFETCH_NUM\fP, $idfield='id', $orderby='')"
.br
.ti -1c
.RI "\fBdb_get_id\fP ($tablename, $index, $idfield='id')"
.br
.ti -1c
.RI "\fBdb_get_index\fP ($tablename, $id, $idfield='id')"
.br
.ti -1c
.RI "\fBdb_get_info\fP ($info='')"
.br
.ti -1c
.RI "\fBdb_get_next_free_id\fP ($tablename, $idfield='id')"
.br
.ti -1c
.RI "\fBdb_list_database_tables\fP ()"
.br
.ti -1c
.RI "\fBdb_list_table_fields\fP ($tablename, $type=false)"
.br
.ti -1c
.RI "\fBdb_open_database\fP ($database, $server='', $username='', $password='')"
.br
.ti -1c
.RI "\fBdb_query\fP ($query)"
.br
.ti -1c
.RI "\fBdb_rename_field\fP ($tablename, $field, $newname, $type)"
.br
.ti -1c
.RI "\fBdb_rename_table\fP ($tablename, $newname)"
.br
.ti -1c
.RI "\fBdb_swap_records\fP ($tablename, $id1, $id2, $idfield='id', $xchangeid=true)"
.br
.ti -1c
.RI "\fBdb_table_exists\fP ($tablename)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fB$_mainpath\fP = pathinfo(__FILE__)"
.br
.ti -1c
.RI "const \fBDB_WRAPVERSION\fP 'db_v2b'"
.br
.ti -1c
.RI "\fBif\fP (!defined('APPPREFIX')) define('APPPREFIX'"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "db_close_database ()"
\fBdb_close_database()\fP

.PP
\fBReturns\fP
.RS 4
bool "TRUE" or "FALSE" 
.RE
.PP

.PP
Definition at line \fB113\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
114 {
115   return raw_db_close_database();
116 }
.PP
.fi

.PP
References \fBraw_db_close_database()\fP\&.
.SS "db_create_database ( $database,  $server = \fR''\fP,  $username = \fR''\fP,  $password = \fR''\fP)"
\fBdb_create_database()\fP Creates a database if it does not exist

.PP
\fBParameters\fP
.RS 4
\fI$database\fP 
.br
\fI$server\fP 
.br
\fI$username\fP 
.br
\fI$password\fP 
.RE
.PP
\fBReturns\fP
.RS 4
resource or "FALSE" 
.RE
.PP

.PP
Definition at line \fB77\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
78 {
79   return raw_db_create_database($database, $server, $username , $password);
80 }
.PP
.fi

.PP
References \fBraw_db_create_database()\fP\&.
.SS "db_create_field ( $tablename,  $field,  $type)"
\fBdb_create_field()\fP

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.br
\fI$field\fP 
.br
\fI$type\fP 
.RE
.PP
\fBReturns\fP
.RS 4
bool "TRUE" or "FALSE" 
.RE
.PP

.PP
Definition at line \fB248\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
249 {
250   return raw_db_create_field(APPPREFIX \&. $tablename, $field, $type);
251 }
.PP
.fi

.PP
References \fBraw_db_create_field()\fP\&.
.SS "db_create_record ( $tablename,  $fieldnames = \fRnull\fP,  $fieldvalues = \fRnull\fP,  $idfield = \fR'id'\fP)"
\fBdb_create_record()\fP

.PP
Insert a new record in table $tablename\&.

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP Table name\&. If NULL uses the table used in last function call\&. 
.br
\fI$fieldnames\fP Array or CSV string with field names, one per line\&. 
.br
\fI$fieldvalues\fP Array or CSV string with field values, one per line\&. 
.br
\fI$idfield\fP 
.RE
.PP
\fBReturns\fP
.RS 4
id of the affected record, FALSE if not succeded 
.RE
.PP

.PP
Definition at line \fB304\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
305 {
306   global $g_lasttable;
307 
308   if (!$tablename)
309     $tablename = $g_lasttable;
310   $g_lasttable = $tablename;
311 
312     if (!$fieldnames) {
313       $fieldnames = db_list_table_fields($tablename);
314       array_shift($fieldnames);
315     }
316     if (!$fieldvalues) {
317       $fieldvalues = array_fill(0, count($fieldnames), 0);
318 
319     }
320   // Get next available index
321   $sql = "SELECT max($idfield) FROM " \&. APPPREFIX \&. $tablename;
322   $result = raw_db_query($sql);
323   if ($result === false) {
324     return false;
325   }
326   $newid = (db_fetch_array($result, FETCH_NUM)) ;
327   $newid = $newid[0] + 1;
328   // Build the two arrays
329   $names = is_string($fieldnames) ? preg_split("/[\\r\\n]/", $fieldnames) : $fieldnames;
330   $values = is_string($fieldvalues) ? preg_split("/[\\r\\n]/", $fieldvalues) : $fieldvalues;
331   if (count($names) != count($values)) {
332     trigger_error(__FUNCTION__ \&. ": both arrays must be same length\&.\\n");
333     return false;
334   }
335   // Build the SQL query
336   $nfields = count($names);
337   $fieldnames = $names;
338   $fieldvalues = $values;
339   for($i = 0, $names = ""; $i < $nfields; $i++)
340   $names \&.= $fieldnames[$i] \&. ($i < $nfields \- 1 ? ", " : "");
341   for($i = 0, $values = ""; $i < $nfields; $i++)
342   $values \&.= "'" \&. db_escape_string($fieldvalues[$i]) \&. "'" \&. ($i < $nfields \- 1 ? ", " : "");
343 
344   $sql = "INSERT INTO " \&. APPPREFIX \&. $tablename \&. " ($idfield, $names) VALUES ($newid, $values)";
345 
346   $result = raw_db_query($sql);
347   if (!$result) {
348     trigger_error(__FUNCTION__ \&. ": could not create new record in table $tablename\&.");
349     return false;
350   }
351   return $newid;
352 }
.PP
.fi

.PP
References \fB$result\fP, \fBdb_escape_string()\fP, \fBdb_fetch_array()\fP, \fBdb_list_table_fields()\fP, \fBFETCH_NUM\fP, and \fBraw_db_query()\fP\&.
.PP
Referenced by \fBdb_create_table()\fP, and \fBdb_edit_record()\fP\&.
.SS "db_create_table ( $tablename,  $fieldnames,  $fieldattrib,  $idfield = \fR'id'\fP,  $valarray = \fRnull\fP)"
\fBdb_create_table()\fP

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.br
\fI$fieldnames\fP ( beside "id" ) 
.br
\fI$fieldattrib\fP 
.br
\fI$idfield\fP ( set to "id" ) 
.br
\fI$valarray\fP ( $valarray[0] = 1\&.record, $valarray[1] = 2\&.record, \&.\&.\&. ) 
.RE
.PP
\fBReturns\fP
.RS 4
bool "TRUE" or "FALSE" if Table already exists, could not create Table, could not create Records 
.RE
.PP

.PP
Definition at line \fB144\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
145 {
146   global $g_lasttable;
147 
148   if ($tablename == null || $tablename == "")
149     $tablename = $g_lasttable;
150   $g_lasttable = $tablename;
151 
152   if (db_table_exists($tablename))
153     return false;
154 
155   if (is_string($fieldnames))
156     $fieldnames = preg_split("/[\\r\\n,]/", $fieldnames);
157   if (is_string($fieldattrib))
158     $fieldattrib = preg_split("/[\\r\\n,]/", $fieldattrib);
159   $attribs = count($fieldattrib);
160   if (count($fieldnames) != $attribs) {
161     trigger_error(__FUNCTION__ \&. ": both arrays must be same length\&.");
162     return false;
163   }
164   $sql = "CREATE TABLE " \&. APPPREFIX \&. "$tablename (";
165   $sql \&.= "$idfield int(11) NOT NULL PRIMARY KEY ";
166   if ($attribs != 0) {
167     $sql \&.= ", ";
168 
169     for($i = 0; $i < $attribs; $i++)
170     $sql \&.= $fieldnames[$i] \&. " " \&. $fieldattrib[$i] \&. ($i < $attribs \- 1 ? ", " : "");
171   }
172   $sql \&.= ")";
173   // Send the sql command
174   $result = raw_db_query($sql);
175   if (!$result) {
176     trigger_error(__FUNCTION__ \&. ": could not create table $tablename\&.");
177     return false;
178   }
179 
180   if ($valarray)
181     foreach($valarray as $values) {
182     $result = db_create_record($tablename, $fieldnames, $values, $idfield);
183     if ($result === false) {
184       return false;
185     }
186   }
187   return $result;
188 }
.PP
.fi

.PP
References \fB$result\fP, \fBdb_create_record()\fP, \fBdb_table_exists()\fP, and \fBraw_db_query()\fP\&.
.SS "db_delete_field ( $tablename,  $field)"
\fBdb_delete_field()\fP

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.br
\fI$field\fP 
.RE
.PP
\fBReturns\fP
.RS 4
bool "TRUE" or "FALSE" 
.RE
.PP

.PP
Definition at line \fB260\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
261 {
262   return raw_db_delete_field(APPPREFIX \&. $tablename, $field);
263 }
.PP
.fi

.PP
References \fBraw_db_delete_field()\fP\&.
.SS "db_delete_records ( $tablename,  $idarray,  $idfield = \fR'id'\fP)"
\fBdb_delete_records()\fP

.PP
Delete record from table $tablename\&.

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.br
\fI$idarray\fP the id or id array 
.RE
.PP
\fBReturns\fP
.RS 4
bool "TRUE" or "FALSE" 
.RE
.PP

.PP
Definition at line \fB363\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
364 {
365   global $g_lasttable;
366 
367   if ($idarray == null || $idarray <= 0)
368     return false;
369   if (!is_array($idarray))
370     $idarray = array($idarray);
371 
372   if (!$tablename)
373     $tablename = $g_lasttable;
374   $g_lasttable = $tablename;
375 
376   foreach($idarray as $item) {
377     // Send the SQL command
378     $sql = "DELETE FROM " \&. APPPREFIX \&. $tablename \&. " WHERE $idfield = " \&. $item;
379     $result = raw_db_query($sql);
380     if (!$result) {
381       trigger_error(__FUNCTION__ \&. ": could not delete record $id in table $tablename\&.");
382       return false;
383     }
384   }
385   return true;
386 }
.PP
.fi

.PP
References \fB$result\fP, and \fBraw_db_query()\fP\&.
.SS "db_delete_table ( $tablename)"
\fBdb_delete_table()\fP

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.RE
.PP
\fBReturns\fP
.RS 4
bool "TRUE" or "FALSE" 
.RE
.PP

.PP
Definition at line \fB196\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
197 {
198   global $g_lasttable;
199 
200   if (!$tablename)
201     $tablename = $g_lasttable;
202   $g_lasttable = $tablename;
203 
204   if ($tablename == null || $tablename == "")
205     return false;
206   if (db_table_exists($tablename))
207     $result = raw_db_query("DROP table " \&. APPPREFIX \&. $tablename);
208   return $result;
209 }
.PP
.fi

.PP
References \fB$result\fP, \fBdb_table_exists()\fP, and \fBraw_db_query()\fP\&.
.SS "db_edit_field ( $tablename,  $field,  $type)"
\fBdb_edit_field()\fP edit field attribute

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.br
\fI$field\fP 
.br
\fI$type\fP 
.RE
.PP
\fBReturns\fP
.RS 4
bool "TRUE" or "FALSE" 
.RE
.PP

.PP
Definition at line \fB288\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
289 {
290   return raw_db_edit_field(APPPREFIX \&. $tablename, $field, $type);
291 }
.PP
.fi

.PP
References \fBraw_db_edit_field()\fP\&.
.SS "db_edit_record ( $tablename,  $id = \fR0\fP,  $fieldnames = \fRnull\fP,  $fieldvalues = \fRnull\fP,  $idfield = \fR'id'\fP)"
\fBdb_edit_record()\fP

.PP
Edits a record from table $tablename\&. If $id is null, zero or < 0, inserts a new record\&.

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP If NULL uses the table used in last function call\&. 
.br
\fI$id\fP 
.br
\fI$fieldnames\fP Array or CSV string with field names, one per line\&. If NULL, affects all fields\&. 
.br
\fI$fieldvalues\fP Array or CSV string with field values, one per line\&. 
.br
\fI$idfield\fP 
.RE
.PP
\fBReturns\fP
.RS 4
id of the affected record or FALSE on error 
.RE
.PP

.PP
Definition at line \fB400\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
401 {
402   global $g_lasttable;
403 
404   if ($id == null || $id <= 0) { // Create a new record
405     return db_create_record($tablename, $fieldnames, $fieldvalues, $idfield);
406   } else { // Edit existing record
407     if (!$tablename)
408       $tablename = $g_lasttable;
409     $g_lasttable = $tablename;
410     // Build the two arrays
411     if (!$fieldnames) {
412       $fieldnames = db_list_table_fields($tablename);
413       array_shift($fieldnames);
414     }
415     if (!$fieldvalues) {
416       $fieldvalues = array_fill(0, count($fieldnames), 0);
417 
418     }
419 
420     $names = is_string($fieldnames) ? preg_split("/[\\r\\n]/", $fieldnames) : $fieldnames;
421     $values = is_string($fieldvalues) ? preg_split("/[\\r\\n]/", $fieldvalues) : $fieldvalues;
422 
423     if (count($names) != count($values)) {
424       trigger_error(__FUNCTION__ \&. ": both arrays must be same length\&.\\n");
425       return false;
426     }
427     // Build the SQL query
428     $nfields = count($names);
429     for($i = 0, $str = ""; $i < $nfields; $i++) {
430       $str \&.= $names[$i] \&. "='" \&. db_escape_string($values[$i]) \&. "'" \&.
431       ($i < $nfields \- 1 ? ", " : "");
432     }
433 
434     $sql = "UPDATE " \&. APPPREFIX \&. "$tablename SET $str WHERE $idfield=$id";
435     // Send the SQL command
436     $result = raw_db_query($sql);
437     if (!$result) {
438       trigger_error(__FUNCTION__ \&. ": could not edit record $id in table $tablename\&.");
439       return false;
440     }
441     return $id;
442   }
443 }
.PP
.fi

.PP
References \fB$result\fP, \fBdb_create_record()\fP, \fBdb_escape_string()\fP, \fBdb_list_table_fields()\fP, and \fBraw_db_query()\fP\&.
.PP
Referenced by \fBdb_swap_records()\fP\&.
.SS "db_escape_string ( $str)"
\fBdb_escape_string()\fP

.PP
\fBParameters\fP
.RS 4
\fI$str\fP 
.RE
.PP
\fBReturns\fP
.RS 4
string escaped 
.RE
.PP
string mysql_real_escape_string ( string unescaped_string [, resource link_identifier])
.PP
Definition at line \fB732\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
733 {
737 
738   return raw_db_escape_string($str);
739 }
.PP
.fi

.PP
References \fBraw_db_escape_string()\fP\&.
.PP
Referenced by \fBdb_create_record()\fP, and \fBdb_edit_record()\fP\&.
.SS "db_fetch_array ( $result,  $type = \fR\fBFETCH_NUM\fP\fP)"
\fBdb_fetch_array()\fP

.PP
\fBParameters\fP
.RS 4
\fI$result\fP 
.br
\fI$type\fP 
.RE
.PP
\fBReturns\fP
.RS 4
array 
.RE
.PP
array mysql_fetch_array ( resource result [, int result_type]) int type MYSQL_ASSOC, MYSQL_NUM ( == fetch_row), and MYSQL_BOTH
.PP
Definition at line \fB705\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
706 {
711 
712   return raw_db_fetch_array($result, $type);
713 }
.PP
.fi

.PP
References \fB$result\fP, \fBFETCH_NUM\fP, and \fBraw_db_fetch_array()\fP\&.
.PP
Referenced by \fBdb_create_record()\fP, \fBdb_get_data()\fP, \fBdb_get_id()\fP, \fBdb_get_next_free_id()\fP, \fBdb_swap_records()\fP, and \fBraw_db_list_table_fields_def()\fP\&.
.SS "db_free_result ( $result)"
\fBdb_free_result()\fP

.PP
\fBParameters\fP
.RS 4
\fI$result\fP 
.RE
.PP
\fBReturns\fP
.RS 4
bool "TRUE" or "FALSE" 
.RE
.PP

.PP
Definition at line \fB721\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
722 {
723   return raw_db_free_result($result);
724 }
.PP
.fi

.PP
References \fB$result\fP, and \fBraw_db_free_result()\fP\&.
.PP
Referenced by \fBdb_get_data()\fP, and \fBdb_get_id()\fP\&.
.SS "db_get_data ( $tablename,  $id = \fRnull\fP,  $col = \fRnull\fP,  $where = \fR''\fP,  $result_type = \fR\fBFETCH_NUM\fP\fP,  $idfield = \fR'id'\fP,  $orderby = \fR''\fP)"
\fBdb_get_data()\fP

.PP
Reads data from table $tablename\&.

.PP
$tablename Table name\&. If NULL uses the table used in last function call\&. $id Identifier(s)\&. May be an array or a CSV string $col Column(s) or field(s)\&. May be an array or a CSV string $where Additional WHERE clause $result_type May be FETCH_ASSOC, FETCH_BOTH or FETCH_NUM $idfield Name of id field $orderby Additional ORDER BY clause
.SS "$id $col returns"
int null array with the whole record $id int str the value of column $col from record $id int str[] array with column values in array $col of record $id int[] null array of arrays with values from all columns of the $id registers int[] str array with the values of column $col from the $id registers int[] str[] 2-D array with the values of columns $col from the $id registers null null array of arrays with the whole table null str array with values of the $col column from the whole table null str[] array of arrays with the values of the columns $col from all table

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.br
\fI$id\fP 
.br
\fI$col\fP 
.br
\fI$where\fP 
.br
\fI$result_type\fP 
.br
\fI$idfield\fP 
.br
\fI$orderby\fP 
.RE
.PP
\fBReturns\fP
.RS 4
result or FALSE 
.RE
.PP

.PP
Definition at line \fB535\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
536 {
537   global $g_lasttable;
538 
539   if (!$tablename)
540     $tablename = $g_lasttable;
541   $g_lasttable = $tablename;
542 
543   if (is_array($col))
544     $col = implode(",", $col);
545   if ($col === null || $col === "")
546     $col = "*";
547   // Build the WHERE clause
548   if ($id !== null) {
549     if (is_string($id) && strstr($id, ",")) {
550       $id = explode(",", $id);
551     }
552     if (is_array($id)) {
553       $idcond = "";
554       for($i = 0; $i < count($id); $i++)
555       $idcond \&.= "$idfield = '{$id[$i]}'" \&. ($i < count($id) \- 1 ? " OR " : "");
556     } else
557       $idcond = "$idfield = '$id'";
558 
559     $condition = $where ? " WHERE ($where) AND ($idcond)" : " WHERE ($idcond)";
560   } else
561     $condition = $where ? " WHERE ($where)" : "";
562 
563   $orderby = $orderby ? " ORDER BY $orderby" : "";
564   // Do the query
565   $sql = "SELECT $col FROM " \&. APPPREFIX \&. $tablename \&. $condition \&. $orderby;
566 
567   $result = raw_db_query($sql);
568   if (!$result)
569     return false;
570   // Loop to build the return array
571   $array = array();
572   while ($row = db_fetch_array($result, $result_type)) {
573     if (count($row) == 1)
574       $row = array_shift($row);
575     $array[] = $row;
576   }
577   if (db_free_result($result) === false) return false;
578   // Return the result
579   if (!is_array($array))
580     return $array;
581 
582   switch (count($array)) {
583     case 0:
584       return false;
585 
586     case 1:
587 
588       $test = $array; // Copy array
589       $elem = array_shift($test); // 1st element of array\&.\&.\&.
590       if (is_null($elem)) // \&.\&.\&.is it null?
591         return false; // Yes: return null
592       if (is_scalar($elem)) // \&.\&.\&.is it a scalar?
593         return $elem; // Yes: return the element alone
594       else
595         return $array; // No: return the whole array
596     default:
597       return $array;
598   }
599 }
.PP
.fi

.PP
References \fB$result\fP, \fBdb_fetch_array()\fP, \fBdb_free_result()\fP, \fBFETCH_NUM\fP, and \fBraw_db_query()\fP\&.
.PP
Referenced by \fBdb_get_index()\fP\&.
.SS "db_get_id ( $tablename,  $index,  $idfield = \fR'id'\fP)"
\fBdb_get_id()\fP

.PP
Returns the id of the record indexed by $index

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.br
\fI$index\fP 
.br
\fI$idfield\fP 
.RE
.PP
\fBReturns\fP
.RS 4
id or FALSE 
.RE
.PP

.PP
Definition at line \fB629\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
630 {
631   global $g_lasttable;
632 
633   if (!is_scalar($index)) {
634     trigger_error(__FUNCTION__ \&. ": index must be an integer");
635     return false;
636   } else
637     $index = (int)$index;
638 
639   if (!$tablename)
640     $tablename = $g_lasttable;
641   $g_lasttable = $tablename;
642 
643   // Do the query
644   $sql = "SELECT $idfield FROM " \&. APPPREFIX \&. $tablename \&. " LIMIT 1 OFFSET $index";
645 
646   $result = raw_db_query($sql);
647   if (!$result)
648     return false;
649 
650   $ret = db_fetch_array($result, FETCH_NUM);
651 
652   if (db_free_result($result) === false)
653     return false;
654 
655   return $ret[0];
656 }
.PP
.fi

.PP
References \fB$result\fP, \fBdb_fetch_array()\fP, \fBdb_free_result()\fP, \fBFETCH_NUM\fP, and \fBraw_db_query()\fP\&.
.SS "db_get_index ( $tablename,  $id,  $idfield = \fR'id'\fP)"
\fBdb_get_index()\fP

.PP
Returns the index of the record identified by $id

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.br
\fI$id\fP 
.br
\fI$idfield\fP 
.RE
.PP
\fBReturns\fP
.RS 4
index or FALSE 
.RE
.PP

.PP
Definition at line \fB612\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
613 {
614   $data = db_get_data($tablename, null, $idfield);
615   return array_search($id, $data);
616 }
.PP
.fi

.PP
References \fBdb_get_data()\fP\&.
.SS "db_get_info ( $info = \fR''\fP)"
\fBdb_get_info()\fP Returns database and wrapper version information

.PP
\fBParameters\fP
.RS 4
\fI$what\fP 
.RE
.PP
\fBReturns\fP
.RS 4
string 
.RE
.PP

.PP
Definition at line \fB35\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
36 {
37   switch (strtolower($info)) {
38     case "version":
39       return DB_DATABASE \&. " " \&. raw_get_db_version() \&. " with Database Wrapper " \&. DB_WRAPVERSION;
40 
41     case "dbtype":
42       return DB_DATABASE;
43 
44     case "dbversion":
45       return raw_get_db_version();
46 
47     case "wrapversion":
48       return DB_WRAPVERSION;
49   }
50 }
.PP
.fi

.PP
References \fBDB_WRAPVERSION\fP, and \fBraw_get_db_version()\fP\&.
.SS "db_get_next_free_id ( $tablename,  $idfield = \fR'id'\fP)"
\fBdb_get_next_free_id()\fP

.PP
Returns the next available id in table $tablename\&.

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.br
\fI$idfield\fP 
.RE
.PP
\fBReturns\fP
.RS 4
id or FALSE 
.RE
.PP

.PP
Definition at line \fB667\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
668 {
669   global $g_current_db;
670   global $g_lasttable;
671 
672   if (!$tablename)
673     $tablename = $g_lasttable;
674   $g_lasttable = $tablename;
675 
676   $sql = "SELECT max($idfield) FROM " \&. APPPREFIX \&. $tablename;
677   $result = raw_db_query($sql);
678   if (!$result) {
679     return false;
680   }
681   $maxid = (db_fetch_array($result, FETCH_NUM)) ;
682 
683   return $maxid[0] + 1;
684 }
.PP
.fi

.PP
References \fB$result\fP, \fBdb_fetch_array()\fP, \fBFETCH_NUM\fP, and \fBraw_db_query()\fP\&.
.PP
Referenced by \fBdb_swap_records()\fP\&.
.SS "db_list_database_tables ()"
\fBdb_list_database_tables()\fP Returns an array with the list of tables of the current database

.PP
\fBReturns\fP
.RS 4
result or "FALSE" 
.RE
.PP

.PP
Definition at line \fB88\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
89 {
90   $tables = raw_db_list_database_tables();
91   if (!$tables) {
92     return false;
93   }
94   $tmp_tabs = "";
95   $prefixlen = strlen(trim(APPPREFIX));
96   if ($prefixlen > 0) {
97     foreach($tables as $table) {
98       if (!(stristr(substr($table, 0, $prefixlen), APPPREFIX) === false)) {
99         $tmp_tabs[] = substr($table, strlen(APPPREFIX));
100       }
101     }
102     if ($tmp_tabs == "") {
103       return false;
104     }
105     return $tmp_tabs;
106   } else return $tables;
107 }
.PP
.fi

.PP
References \fBraw_db_list_database_tables()\fP\&.
.SS "db_list_table_fields ( $tablename,  $type = \fRfalse\fP)"
\fBdb_list_table_fields()\fP

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.RE
.PP
\fBReturns\fP
.RS 4
array with the names of the fields of table $tablename or FALSE 
.RE
.PP

.PP
Definition at line \fB228\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
229 {
230   global $g_lasttable;
231 
232   if (!$tablename)
233     $tablename = $g_lasttable;
234   $g_lasttable = $tablename;
235 
236   $result = raw_db_list_table_fields_def(APPPREFIX \&. $tablename, $type);
237   return $result;
238 }
.PP
.fi

.PP
References \fB$result\fP, and \fBraw_db_list_table_fields_def()\fP\&.
.PP
Referenced by \fBdb_create_record()\fP, and \fBdb_edit_record()\fP\&.
.SS "db_open_database ( $database,  $server = \fR''\fP,  $username = \fR''\fP,  $password = \fR''\fP)"
\fBdb_open_database()\fP Opens and connects an existing database\&.

.PP
\fBParameters\fP
.RS 4
\fI$database\fP 
.br
\fI$server\fP 
.br
\fI$username\fP 
.br
\fI$password\fP 
.RE
.PP
\fBReturns\fP
.RS 4
resource or "FALSE" 
.RE
.PP

.PP
Definition at line \fB62\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
63 {
64   return raw_db_open_database($database, $server, $username , $password);
65 }
.PP
.fi

.PP
References \fBraw_db_open_database()\fP\&.
.SS "db_query ( $query)"
depricated exists only for compatibility to previous version is the same as raw_db_query does not handle APPPREFIX 
.PP
Definition at line \fB693\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
694 {
695   return raw_db_query($query);
696 }
.PP
.fi

.PP
References \fBraw_db_query()\fP\&.
.PP
Referenced by \fBraw_db_list_table_fields_def()\fP\&.
.SS "db_rename_field ( $tablename,  $field,  $newname,  $type)"
\fBdb_rename_field()\fP

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.br
\fI$field\fP 
.br
\fI$newname\fP 
.br
\fI$type\fP 
.RE
.PP
\fBReturns\fP
.RS 4
bool "TRUE" or "FALSE" 
.RE
.PP

.PP
Definition at line \fB274\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
275 {
276   return raw_db_rename_field(APPPREFIX \&. $tablename, $field, $newname, $type);
277 }
.PP
.fi

.PP
References \fBraw_db_rename_field()\fP\&.
.SS "db_rename_table ( $tablename,  $newname)"
\fBdb_rename_table()\fP

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.br
\fI$newname\fP 
.RE
.PP
\fBReturns\fP
.RS 4
bool "TRUE" or "FALSE" 
.RE
.PP

.PP
Definition at line \fB218\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
219 {
220   return raw_db_rename_table(APPPREFIX \&. $tablename, APPPREFIX \&. $newname);
221 }
.PP
.fi

.PP
References \fBraw_db_rename_table()\fP\&.
.SS "db_swap_records ( $tablename,  $id1,  $id2,  $idfield = \fR'id'\fP,  $xchangeid = \fRtrue\fP)"
\fBdb_swap_records()\fP

.PP
Swaps values from two records, including the id field or not according to $xchangeid\&.

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP 
.br
\fI$id1\fP 
.br
\fI$id2\fP 
.br
\fI$idfield\fP 
.br
\fI$xchangeid\fP 
.RE
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.PP
Definition at line \fB457\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
458 {
459   global $g_lasttable;
460   // Table name
461   if (!$tablename)
462     $tablename = $g_lasttable;
463   $g_lasttable = $tablename;
464   $table = APPPREFIX \&. "$tablename";
465   // Build SQL strings
466   $result = raw_db_query("SELECT * FROM $table WHERE $idfield = $id1");
467   if (!$result) {
468     trigger_error(__FUNCTION__ \&. ": could not read record $id1 in table $tablename\&.");
469     return false;
470   }
471   $a = db_fetch_array($result, FETCH_ASSOC);
472   $fieldvalues1 = array_values($a);
473   $fieldnames1 = array_keys($a);
474   array_shift($fieldvalues1);
475   array_shift($fieldnames1);
476 
477   $result = raw_db_query("SELECT * FROM $table WHERE $idfield = $id2");
478   if (!$result) {
479     trigger_error(__FUNCTION__ \&. ": could not read record $id2 in table $tablename\&.");
480     return false;
481   }
482   $a = db_fetch_array($result, FETCH_ASSOC);
483   $fieldvalues2 = array_values($a);
484   $fieldnames2 = array_keys($a);
485   array_shift($fieldvalues2);
486   array_shift($fieldnames2);
487   // Exchange values
488   if (db_edit_record($tablename, $id1, $fieldnames2, $fieldvalues2, $idfield) === false) return false;
489   if (db_edit_record($tablename, $id2, $fieldnames1, $fieldvalues1, $idfield) === false) return false;
490   // Exchange id's
491   if ($xchangeid) {
492     $unique = db_get_next_free_id($tablename);
493     if (db_edit_record($tablename, $id1, array($idfield), array($unique), $idfield) === false) return false;
494     if (db_edit_record($tablename, $id2, array($idfield), array($id1), $idfield) === false) return false;
495     if (db_edit_record($tablename, $unique, array($idfield), array($id2), $idfield) === false) return false;
496   }
497   return true;
498 }
.PP
.fi

.PP
References \fB$result\fP, \fBdb_edit_record()\fP, \fBdb_fetch_array()\fP, \fBdb_get_next_free_id()\fP, \fBFETCH_ASSOC\fP, and \fBraw_db_query()\fP\&.
.SS "db_table_exists ( $tablename)"
\fBdb_table_exists()\fP

.PP
\fBParameters\fP
.RS 4
\fI$tablename\fP of an opened database 
.RE
.PP
\fBReturns\fP
.RS 4
bool "TRUE" if table $tablename exists in the current database 
.RE
.PP

.PP
Definition at line \fB124\fP of file \fBdb_common\&.inc\&.php\fP\&.
.nf
125 {
126   global $g_lasttable;
127 
128   if (!$tablename)
129     $tablename = $g_lasttable;
130   $g_lasttable = $tablename;
131   return raw_db_table_exists(APPPREFIX \&. $tablename);
132 }
.PP
.fi

.PP
References \fBraw_db_table_exists()\fP\&.
.PP
Referenced by \fBdb_create_table()\fP, and \fBdb_delete_table()\fP\&.
.SH "Variable Documentation"
.PP 
.SS "$_mainpath = pathinfo(__FILE__)"

.PP
Definition at line \fB23\fP of file \fBdb_common\&.inc\&.php\fP\&.
.SS "const DB_WRAPVERSION 'db_v2b'"
WINBINDER - The native Windows binding for PHP for PHP

.PP
Copyright Hypervisual - see LICENSE\&.TXT for details Authors: Rubem Pechansky and Hans Rebel

.PP
Database wrapper functions for \fBWinBinder\fP version 2b tested with SQLite and mySQL 7\&.mar 
.PP
Definition at line \fB18\fP of file \fBdb_common\&.inc\&.php\fP\&.
.PP
Referenced by \fBdb_get_info()\fP\&.
.SS "if(!defined('DB_DATABASE')) define('DB_DATABASE' (! defined'APPPREFIX')"

.PP
Definition at line \fB20\fP of file \fBdb_common\&.inc\&.php\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Bearsampp from the source code\&.
